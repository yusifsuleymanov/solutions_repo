{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 # Theoretical Foundation Derivation of Projectile Motion from Newton's Laws We begin by considering a projectile launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) above the horizontal. The motion can be decomposed into two perpendicular components: Horizontal (x-axis) Vertical (y-axis) Assumptions: No air resistance Constant gravitational acceleration \\(g\\) Launched from the origin at time \\(t = 0\\) 1. Equations of Motion Horizontal motion (constant velocity): Acceleration: \\(a_x=0\\) Velocity: \\(v_x=v_0\\cos(\\theta)\\) Displacement: \\( \\(x(t)=v_0\\cos(\\theta)\\cdot t\\) \\) Vertical motion (accelerated motion): Acceleration: \\(a_y=-g\\) Velocity: \\(v_y=v_0\\sin(\\theta)-gt\\) Displacement: \\( \\(y(t)=v_0\\sin(\\theta)\\cdot t-\\frac{1}{2}gt^2\\) \\) 2. Time of Flight The projectile hits the ground when \\(y(t) = 0\\) . Solving: \\[ v_0\\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 = 0 \\] \\[ t(v_0\\sin(\\theta) - \\frac{1}{2}gt) = 0 \\] Non-zero solution: \\[ t = \\frac{2v_0\\sin(\\theta)}{g} \\] \u2194 3. Horizontal Range \\(R\\) Substitute the total time of flight into the horizontal displacement: \\[ R = x(t) = v_0\\cos(\\theta) \\cdot \\frac{2v_0\\sin(\\theta)}{g} \\] \\[ \\boxed{R = \\frac{v_0^2\\sin(2\\theta)}{g}} \\] This shows that range is maximum when \\(\\sin(2\\theta) = 1\\) , i.e. \\(\\theta = 45^\\circ\\) 4. Effect of Initial Conditions on Range Initial Velocity \\(v_0\\) : Range is proportional to \\(v_0^2\\) Doubling speed increases range fourfold Angle \\(\\theta\\) : Affects both vertical and horizontal components Maximum range at \\(\\theta = 45^\\circ\\) (in symmetric conditions) Gravitational Acceleration \\(g\\) : Inverse relation: higher gravity \u2192 shorter range Launch Height (not included above) : Adds vertical displacement Increases total time in air \u2192 longer range (needs new derivation) These equations form the idealized model of projectile motion, laying the foundation for further numerical or simulation-based analysis. Analysis of the Range 1. Mathematical Relationship Between Range and Angle Using the derived formula from earlier: \\[ R=\\frac{v_0^2\\sin(2\\theta)}{g} \\] Where: - \\(R\\) is the horizontal range - \\(v_0\\) is the initial velocity - \\(\\theta\\) is the launch angle - \\(g\\) is the acceleration due to gravity Key Observations: Range depends non-linearly on \\(\u03b8\\) through \\(sin(2\u03b8)\\) . The function \\(sin(2\u03b8)\\) reaches its maximum value of 1 when \\(2\u03b8=90\u00b0\\) . Therefore, the maximum range occurs at: \\( \\(\\boxed{\u03b8=45\u00b0}\\) \\) 2. Effect of Initial Velocity ( \\(v_0\\) ) From the formula: \\[ R\\propto v_0^2 \\] Doubling \\(v_0\\) quadruples the range. Plotting range vs. angle for different velocities shifts the amplitude of the curve but not the position of the peak. 3. Effect of Gravitational Acceleration ( \\(g\\) ) Range is inversely proportional to \\(g\\) : \\[ R\\propto\\frac{1}{g} \\] Lower gravity (e.g., on the Moon) results in a longer range . Higher gravity (e.g., on Jupiter) produces a shorter range . 4. Launch Height (Advanced) When the projectile is launched from a height \\(h>0\\) , total time of flight increases. The vertical displacement becomes: \\[ y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2+h \\] To find time of flight \\(t_f\\) , solve: \\[ 0=h+v_0\\sin(\\theta)t_f-\\frac{1}{2}gt_f^2 \\] This is a quadratic in \\(t_f\\) : \\[ \\frac{1}{2}gt_f^2-v_0\\sin(\\theta)t_f-h=0 \\] Solve for \\(t_f\\) using the quadratic formula: \\[ t_f=\\frac{v_0\\sin(\\theta)+\\sqrt{(v_0\\sin(\\theta))^2+2gh}}{g} \\] Then calculate range: \\[ R=v_0\\cos(\\theta)\\cdot t_f \\] Note: Range increases with height. The angle for maximum range no longer remains 45\u00b0 when launching from a height. Summary Parameter Effect on Range Initial Velocity \\(v_0\\) Quadratic increase ( \\(\\propto v_0^2\\) ) Launch Angle \\(\\theta\\) Max at \\(45^\\circ\\) (flat launch) Gravity \\(g\\) Inversely proportional Launch Height \\(h\\) Increases range, changes optimal angle This analysis provides a full picture of how the range responds to varying parameters in ideal and slightly more realistic conditions. Practical Applications of Projectile Motion 1. Real-World Situations Involving Projectile Motion Projectile motion is observed in various natural and engineered systems: Sports: A soccer ball, basketball, or javelin follows a projectile path after being launched. The initial velocity and launch angle determine whether the ball reaches the goal or basket. Engineering: Water fountains or fire hoses arc based on launch parameters. Ballistics in defense and aerospace engineering heavily depend on accurate projectile modeling. Astrophysics: Space missions use orbital mechanics \u2014 an extension of projectile motion under gravity. Launching a probe involves solving similar equations in non-Earth gravity fields. 2. Effects of Terrain, Drag, and Wind a. Uneven Terrain When projectiles land on non-flat surfaces , the simple range formula no longer applies. Suppose the landing height is different from the launch height \\(h_0\\) , then total time of flight \\(t_f\\) must be found by solving: \\[ y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2+h_0 \\] Final range becomes: \\[ R=v_0\\cos(\\theta)\\cdot t_f \\] Requires solving a quadratic equation for \\(t_f\\) and using it in range computation. b. Air Resistance (Drag) Real trajectories are affected by drag force proportional to velocity: \\[ F_d=-kv \\] Where: - \\(F_d\\) is the drag force, - \\(k\\) is a constant depending on air density and shape, - \\(v\\) is velocity. This leads to nonlinear differential equations : In horizontal direction: \\[m\\frac{dv_x}{dt}=-kv_x\\] In vertical direction: \\[m\\frac{dv_y}{dt}=-mg-kv_y\\] These must be solved numerically using techniques like Euler\u2019s method or Runge-Kutta. c. Wind Wind introduces additional velocity components: - Tailwind increases range. - Headwind decreases range. - Crosswind changes the direction of the projectile, affecting accuracy. Effective horizontal velocity becomes: \\[ v_{\\text{effective}}=v_0\\cos(\\theta)\\pm v_{\\text{wind}} \\] 3. Adapting the Model To make the model more realistic: Include drag : Use numerical simulation (e.g., Runge-Kutta) to solve motion with air resistance. Include wind : Modify initial velocity vector to account for wind speed and direction. Simulate terrain : Adjust impact height based on known terrain elevation data. Summary Realistic Factor Effect on Range Modeling Approach Uneven Terrain Alters time of flight Quadratic equation with height offset Air Resistance Shortens range significantly Numerical solution of ODEs Wind Alters path and accuracy Adjust velocity components By expanding our model, we bridge the gap between ideal physics and real-world scenarios, increasing the accuracy and relevance of projectile analysis. Implementation: Computational Simulation of Projectile Motion This section provides a Python implementation to simulate projectile motion, analyze the range as a function of angle, and visualize the effects of varying initial conditions. Objective Simulate projectile motion under ideal conditions. Plot Range vs. Angle of Projection . Allow the user to vary: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Initial height \\(h_0\\) Python Code (Jupyter Notebook Compatible) import numpy as np import matplotlib.pyplot as plt # --- Function to calculate range --- def calculate_range(v0, angle_deg, g=9.81, h0=0): angle_rad = np.radians(angle_deg) v0x = v0 * np.cos(angle_rad) v0y = v0 * np.sin(angle_rad) if h0 == 0: # Flat terrain (simplified range formula) R = (v0**2 * np.sin(2 * angle_rad)) / g else: # Non-zero launch height, solve for time of flight and range t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g R = v0x * t_flight return R # --- Function to simulate and plot --- def plot_range_vs_angle(v0, g=9.81, h0=0): angles = np.linspace(0, 90, 500) ranges = [calculate_range(v0, angle, g, h0) for angle in angles] plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, label=f'v\u2080={v0} m/s, g={g} m/s\u00b2, h\u2080={h0} m') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.show() # --- Example usage --- # Modify these parameters to explore different conditions initial_velocity = 30 # m/s gravity = 9.81 # m/s\u00b2 initial_height = 0 # m plot_range_vs_angle(initial_velocity, gravity, initial_height) import numpy as np import matplotlib.pyplot as plt # --- Function to calculate range --- def calculate_range(v0, angle_deg, g=9.81, h0=0): angle_rad = np.radians(angle_deg) v0x = v0 * np.cos(angle_rad) v0y = v0 * np.sin(angle_rad) if h0 == 0: # Flat terrain (simplified range formula) R = (v0**2 * np.sin(2 * angle_rad)) / g else: # Non-zero launch height, solve for time of flight and range t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g R = v0x * t_flight return R # --- Function to simulate and plot --- def plot_range_vs_angle(v0_values, g=9.81, h0=0): angles = np.linspace(0, 90, 500) plt.figure(figsize=(12, 7)) for v0 in v0_values: ranges = [calculate_range(v0, angle, g, h0) for angle in angles] plt.plot(angles, ranges, label=f'v\u2080 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.title('Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.tight_layout() plt.show() # --- Example usage --- initial_velocities = [10, 20, 30, 40, 50] # m/s gravity = 9.81 # m/s\u00b2 (Earth) initial_height = 0 # m (ground level launch) plot_range_vs_angle(initial_velocities, gravity, initial_height) import numpy as np import matplotlib.pyplot as plt # Function to simulate projectile motion def projectile_motion(v0, angle_deg, g=9.81, h0=0): angle_rad = np.radians(angle_deg) v0x = v0 * np.cos(angle_rad) v0y = v0 * np.sin(angle_rad) # Time of flight if h0 == 0: t_flight = 2 * v0y / g else: t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g t = np.linspace(0, t_flight, num=300) x = v0x * t y = h0 + v0y * t - 0.5 * g * t**2 return x, y # Plot setup g = 9.81 h0 = 0 fig, axs = plt.subplots(2, 1, figsize=(10, 12)) # (a) Fixed angle, changing speeds velocities = [30, 40, 50] angle_fixed = 45 colors = ['r', 'purple', 'green'] for v0, color in zip(velocities, colors): x, y = projectile_motion(v0, angle_fixed, g, h0) axs[0].plot(x, y, color=color, label=f'v\u2080 = {v0} m/s') axs[0].set_title('(a) Constant Angle (45\u00b0), Varying Speeds') axs[0].set_xlabel('x (meters)') axs[0].set_ylabel('y (meters)') axs[0].legend() axs[0].grid(True) axs[0].axis('equal') # (b) Fixed speed, changing angles v0_fixed = 50 angles = [15, 45, 75] for angle, color in zip(angles, colors): x, y = projectile_motion(v0_fixed, angle, g, h0) axs[1].plot(x, y, color=color, label=f'\u03b8 = {angle}\u00b0') axs[1].set_title('(b) Constant Speed (50 m/s), Varying Angles') axs[1].set_xlabel('x (meters)') axs[1].set_ylabel('y (meters)') axs[1].legend() axs[1].grid(True) axs[1].axis('equal') plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-projectile-motion-from-newtons-laws","text":"We begin by considering a projectile launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) above the horizontal. The motion can be decomposed into two perpendicular components: Horizontal (x-axis) Vertical (y-axis)","title":"Derivation of Projectile Motion from Newton's Laws"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#assumptions","text":"No air resistance Constant gravitational acceleration \\(g\\) Launched from the origin at time \\(t = 0\\)","title":"Assumptions:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-equations-of-motion","text":"Horizontal motion (constant velocity): Acceleration: \\(a_x=0\\) Velocity: \\(v_x=v_0\\cos(\\theta)\\) Displacement: \\( \\(x(t)=v_0\\cos(\\theta)\\cdot t\\) \\) Vertical motion (accelerated motion): Acceleration: \\(a_y=-g\\) Velocity: \\(v_y=v_0\\sin(\\theta)-gt\\) Displacement: \\( \\(y(t)=v_0\\sin(\\theta)\\cdot t-\\frac{1}{2}gt^2\\) \\)","title":"1. Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-time-of-flight","text":"The projectile hits the ground when \\(y(t) = 0\\) . Solving: \\[ v_0\\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 = 0 \\] \\[ t(v_0\\sin(\\theta) - \\frac{1}{2}gt) = 0 \\] Non-zero solution: \\[ t = \\frac{2v_0\\sin(\\theta)}{g} \\]","title":"2. Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-horizontal-range-r","text":"Substitute the total time of flight into the horizontal displacement: \\[ R = x(t) = v_0\\cos(\\theta) \\cdot \\frac{2v_0\\sin(\\theta)}{g} \\] \\[ \\boxed{R = \\frac{v_0^2\\sin(2\\theta)}{g}} \\] This shows that range is maximum when \\(\\sin(2\\theta) = 1\\) , i.e. \\(\\theta = 45^\\circ\\)","title":"\u2194 3. Horizontal Range \\(R\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-effect-of-initial-conditions-on-range","text":"Initial Velocity \\(v_0\\) : Range is proportional to \\(v_0^2\\) Doubling speed increases range fourfold Angle \\(\\theta\\) : Affects both vertical and horizontal components Maximum range at \\(\\theta = 45^\\circ\\) (in symmetric conditions) Gravitational Acceleration \\(g\\) : Inverse relation: higher gravity \u2192 shorter range Launch Height (not included above) : Adds vertical displacement Increases total time in air \u2192 longer range (needs new derivation)","title":"4. Effect of Initial Conditions on Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#these-equations-form-the-idealized-model-of-projectile-motion-laying-the-foundation-for-further-numerical-or-simulation-based-analysis","text":"","title":"These equations form the idealized model of projectile motion, laying the foundation for further numerical or simulation-based analysis."},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis-of-the-range","text":"","title":"Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-mathematical-relationship-between-range-and-angle","text":"Using the derived formula from earlier: \\[ R=\\frac{v_0^2\\sin(2\\theta)}{g} \\] Where: - \\(R\\) is the horizontal range - \\(v_0\\) is the initial velocity - \\(\\theta\\) is the launch angle - \\(g\\) is the acceleration due to gravity","title":"1. Mathematical Relationship Between Range and Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-observations","text":"Range depends non-linearly on \\(\u03b8\\) through \\(sin(2\u03b8)\\) . The function \\(sin(2\u03b8)\\) reaches its maximum value of 1 when \\(2\u03b8=90\u00b0\\) . Therefore, the maximum range occurs at: \\( \\(\\boxed{\u03b8=45\u00b0}\\) \\)","title":"Key Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-effect-of-initial-velocity-v_0","text":"From the formula: \\[ R\\propto v_0^2 \\] Doubling \\(v_0\\) quadruples the range. Plotting range vs. angle for different velocities shifts the amplitude of the curve but not the position of the peak.","title":"2. Effect of Initial Velocity (\\(v_0\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-effect-of-gravitational-acceleration-g","text":"Range is inversely proportional to \\(g\\) : \\[ R\\propto\\frac{1}{g} \\] Lower gravity (e.g., on the Moon) results in a longer range . Higher gravity (e.g., on Jupiter) produces a shorter range .","title":"3. Effect of Gravitational Acceleration (\\(g\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-launch-height-advanced","text":"When the projectile is launched from a height \\(h>0\\) , total time of flight increases. The vertical displacement becomes: \\[ y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2+h \\] To find time of flight \\(t_f\\) , solve: \\[ 0=h+v_0\\sin(\\theta)t_f-\\frac{1}{2}gt_f^2 \\] This is a quadratic in \\(t_f\\) : \\[ \\frac{1}{2}gt_f^2-v_0\\sin(\\theta)t_f-h=0 \\] Solve for \\(t_f\\) using the quadratic formula: \\[ t_f=\\frac{v_0\\sin(\\theta)+\\sqrt{(v_0\\sin(\\theta))^2+2gh}}{g} \\] Then calculate range: \\[ R=v_0\\cos(\\theta)\\cdot t_f \\]","title":"4. Launch Height (Advanced)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#note","text":"Range increases with height. The angle for maximum range no longer remains 45\u00b0 when launching from a height.","title":"Note:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#summary","text":"Parameter Effect on Range Initial Velocity \\(v_0\\) Quadratic increase ( \\(\\propto v_0^2\\) ) Launch Angle \\(\\theta\\) Max at \\(45^\\circ\\) (flat launch) Gravity \\(g\\) Inversely proportional Launch Height \\(h\\) Increases range, changes optimal angle","title":"Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#this-analysis-provides-a-full-picture-of-how-the-range-responds-to-varying-parameters-in-ideal-and-slightly-more-realistic-conditions","text":"","title":"This analysis provides a full picture of how the range responds to varying parameters in ideal and slightly more realistic conditions."},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications-of-projectile-motion","text":"","title":"Practical Applications of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-real-world-situations-involving-projectile-motion","text":"Projectile motion is observed in various natural and engineered systems: Sports: A soccer ball, basketball, or javelin follows a projectile path after being launched. The initial velocity and launch angle determine whether the ball reaches the goal or basket. Engineering: Water fountains or fire hoses arc based on launch parameters. Ballistics in defense and aerospace engineering heavily depend on accurate projectile modeling. Astrophysics: Space missions use orbital mechanics \u2014 an extension of projectile motion under gravity. Launching a probe involves solving similar equations in non-Earth gravity fields.","title":"1. Real-World Situations Involving Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-effects-of-terrain-drag-and-wind","text":"","title":"2. Effects of Terrain, Drag, and Wind"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#a-uneven-terrain","text":"When projectiles land on non-flat surfaces , the simple range formula no longer applies. Suppose the landing height is different from the launch height \\(h_0\\) , then total time of flight \\(t_f\\) must be found by solving: \\[ y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2+h_0 \\] Final range becomes: \\[ R=v_0\\cos(\\theta)\\cdot t_f \\] Requires solving a quadratic equation for \\(t_f\\) and using it in range computation.","title":"a. Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#b-air-resistance-drag","text":"Real trajectories are affected by drag force proportional to velocity: \\[ F_d=-kv \\] Where: - \\(F_d\\) is the drag force, - \\(k\\) is a constant depending on air density and shape, - \\(v\\) is velocity. This leads to nonlinear differential equations : In horizontal direction: \\[m\\frac{dv_x}{dt}=-kv_x\\] In vertical direction: \\[m\\frac{dv_y}{dt}=-mg-kv_y\\] These must be solved numerically using techniques like Euler\u2019s method or Runge-Kutta.","title":"b. Air Resistance (Drag)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#c-wind","text":"Wind introduces additional velocity components: - Tailwind increases range. - Headwind decreases range. - Crosswind changes the direction of the projectile, affecting accuracy. Effective horizontal velocity becomes: \\[ v_{\\text{effective}}=v_0\\cos(\\theta)\\pm v_{\\text{wind}} \\]","title":"c. Wind"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-adapting-the-model","text":"To make the model more realistic: Include drag : Use numerical simulation (e.g., Runge-Kutta) to solve motion with air resistance. Include wind : Modify initial velocity vector to account for wind speed and direction. Simulate terrain : Adjust impact height based on known terrain elevation data.","title":"3. Adapting the Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#summary_1","text":"Realistic Factor Effect on Range Modeling Approach Uneven Terrain Alters time of flight Quadratic equation with height offset Air Resistance Shortens range significantly Numerical solution of ODEs Wind Alters path and accuracy Adjust velocity components By expanding our model, we bridge the gap between ideal physics and real-world scenarios, increasing the accuracy and relevance of projectile analysis.","title":"Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation-computational-simulation-of-projectile-motion","text":"This section provides a Python implementation to simulate projectile motion, analyze the range as a function of angle, and visualize the effects of varying initial conditions.","title":"Implementation: Computational Simulation of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#objective","text":"Simulate projectile motion under ideal conditions. Plot Range vs. Angle of Projection . Allow the user to vary: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Initial height \\(h_0\\)","title":"Objective"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-jupyter-notebook-compatible","text":"","title":"Python Code (Jupyter Notebook Compatible)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_1","text":"import numpy as np import matplotlib.pyplot as plt # --- Function to calculate range --- def calculate_range(v0, angle_deg, g=9.81, h0=0): angle_rad = np.radians(angle_deg) v0x = v0 * np.cos(angle_rad) v0y = v0 * np.sin(angle_rad) if h0 == 0: # Flat terrain (simplified range formula) R = (v0**2 * np.sin(2 * angle_rad)) / g else: # Non-zero launch height, solve for time of flight and range t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g R = v0x * t_flight return R # --- Function to simulate and plot --- def plot_range_vs_angle(v0, g=9.81, h0=0): angles = np.linspace(0, 90, 500) ranges = [calculate_range(v0, angle, g, h0) for angle in angles] plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, label=f'v\u2080={v0} m/s, g={g} m/s\u00b2, h\u2080={h0} m') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.show() # --- Example usage --- # Modify these parameters to explore different conditions initial_velocity = 30 # m/s gravity = 9.81 # m/s\u00b2 initial_height = 0 # m plot_range_vs_angle(initial_velocity, gravity, initial_height)","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_2","text":"import numpy as np import matplotlib.pyplot as plt # --- Function to calculate range --- def calculate_range(v0, angle_deg, g=9.81, h0=0): angle_rad = np.radians(angle_deg) v0x = v0 * np.cos(angle_rad) v0y = v0 * np.sin(angle_rad) if h0 == 0: # Flat terrain (simplified range formula) R = (v0**2 * np.sin(2 * angle_rad)) / g else: # Non-zero launch height, solve for time of flight and range t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g R = v0x * t_flight return R # --- Function to simulate and plot --- def plot_range_vs_angle(v0_values, g=9.81, h0=0): angles = np.linspace(0, 90, 500) plt.figure(figsize=(12, 7)) for v0 in v0_values: ranges = [calculate_range(v0, angle, g, h0) for angle in angles] plt.plot(angles, ranges, label=f'v\u2080 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.title('Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.tight_layout() plt.show() # --- Example usage --- initial_velocities = [10, 20, 30, 40, 50] # m/s gravity = 9.81 # m/s\u00b2 (Earth) initial_height = 0 # m (ground level launch) plot_range_vs_angle(initial_velocities, gravity, initial_height)","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_3","text":"import numpy as np import matplotlib.pyplot as plt # Function to simulate projectile motion def projectile_motion(v0, angle_deg, g=9.81, h0=0): angle_rad = np.radians(angle_deg) v0x = v0 * np.cos(angle_rad) v0y = v0 * np.sin(angle_rad) # Time of flight if h0 == 0: t_flight = 2 * v0y / g else: t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g t = np.linspace(0, t_flight, num=300) x = v0x * t y = h0 + v0y * t - 0.5 * g * t**2 return x, y # Plot setup g = 9.81 h0 = 0 fig, axs = plt.subplots(2, 1, figsize=(10, 12)) # (a) Fixed angle, changing speeds velocities = [30, 40, 50] angle_fixed = 45 colors = ['r', 'purple', 'green'] for v0, color in zip(velocities, colors): x, y = projectile_motion(v0, angle_fixed, g, h0) axs[0].plot(x, y, color=color, label=f'v\u2080 = {v0} m/s') axs[0].set_title('(a) Constant Angle (45\u00b0), Varying Speeds') axs[0].set_xlabel('x (meters)') axs[0].set_ylabel('y (meters)') axs[0].legend() axs[0].grid(True) axs[0].axis('equal') # (b) Fixed speed, changing angles v0_fixed = 50 angles = [15, 45, 75] for angle, color in zip(angles, colors): x, y = projectile_motion(v0_fixed, angle, g, h0) axs[1].plot(x, y, color=color, label=f'\u03b8 = {angle}\u00b0') axs[1].set_title('(b) Constant Speed (50 m/s), Varying Angles') axs[1].set_xlabel('x (meters)') axs[1].set_ylabel('y (meters)') axs[1].legend() axs[1].grid(True) axs[1].axis('equal') plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation The forced damped pendulum is governed by a second-order nonlinear ordinary differential equation (ODE) that models the angular displacement of a pendulum subjected to both damping and an external periodic force. \ud83d\udccc Governing Differential Equation The general equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] Where: \\(\\theta(t)\\) : Angular displacement as a function of time \\(b\\) : Damping coefficient \\(g\\) : Acceleration due to gravity \\(L\\) : Length of the pendulum \\(A\\) : Amplitude of the external driving force \\(\\omega\\) : Angular frequency of the driving force he driving force \ud83d\udd0d Small-Angle Approximation Under the small-angle approximation (where \\(\\theta \\ll 1\\) ), we can linearize the sine function as follows: \\[\\sin\\theta \\approx \\theta\\] This simplification reduces the governing equation to a linear inhomogeneous ordinary differential equation (ODE) : \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t)\\] \ud83d\udcd0 Analytical Solution for Small Angles The general solution to the linearized ODE consists of two parts: Homogeneous solution (related to natural damping): \\( \\(\\theta_h(t)=C_1e^{r_1t}+C_2e^{r_2t}\\) \\) where \\(r_1,r_2\\) are roots of the characteristic equation: \\( \\(r^2+br+\\frac{g}{L}=0\\) \\) Particular solution (related to the external forcing): We assume a steady-state solution of the form: \\[\\theta_p(t)=B\\cos(\\omega t-\\delta)\\] where: The amplitude of the forced oscillation is denoted by \\(B\\) , and the phase lag due to damping is denoted by \\(\\delta\\) . The amplitude of the steady-state response is given by: \\[B=\\frac{A}{\\sqrt{\\left(\\frac{g}{L}-\\omega^2\\right)^2+(b\\omega)^2}}\\] \ud83c\udfaf Resonance Condition Resonance occurs when the driving frequency \\(\\omega\\) approaches the natural frequency of the system: \\[ \\omega_0=\\sqrt{\\frac{g}{L}} \\] At resonance, the system absorbs energy most efficiently from the external force, and the amplitude \\(B\\) reaches a maximum: Without damping ( \\(b=0\\) ): \\[ B\\to\\infty\\quad\\text{as}\\quad\\omega\\to\\omega_0 \\] With damping: \\[ B_{\\text{max}}=\\frac{A}{b\\omega_0} \\] This finite maximum occurs at a slightly shifted resonance frequency: \\[ \\omega_{\\text{res}}=\\sqrt{\\omega_0^2-\\frac{b^2}{2}} \\] \u26a1 Energy Behavior at Resonance The total mechanical energy of the pendulum is the sum of kinetic and potential energy: \\[ E(t) = \\frac{1}{2} m L^2 \\left(\\frac{d\\theta}{dt}\\right)^2 + mgL(1 - \\cos\\theta) \\] Under resonance: The system continually absorbs energy from the external force. The kinetic energy grows in the undamped case. In the damped case, energy input is balanced by dissipation: Leads to a steady-state oscillation. The energy oscillates but remains bounded. \u2705 Summary The equation of motion combines restoring, damping, and external driving forces. Linearization using \\(\\sin\\theta \\approx \\theta\\) simplifies the analysis for small oscillations. Resonance amplifies oscillation amplitudes and affects energy flow. Damping ensures bounded energy growth even at resonance. Investigating the Dynamics of a Forced Damped Pendulum 2. Analysis of Dynamics In this section, we will investigate how the dynamics of the forced damped pendulum are influenced by key parameters such as the damping coefficient \\(b\\) , driving amplitude \\(A\\) , and driving frequency \\(\\omega\\) . Additionally, we will explore the transition between regular motion and chaotic behavior , and interpret the physical meaning of these transitions. \ud83d\udcca Effect of Damping Coefficient \\(b\\) The damping coefficient \\(b\\) plays a crucial role in determining the behavior of the system: For low damping ( \\(b \\to 0\\) ), the pendulum oscillates with large amplitudes, and the system is primarily influenced by the restoring force and external periodic force. For high damping ( \\(b \\to \\infty\\) ), the pendulum quickly returns to rest, and the oscillations decay exponentially. Mathematically, the solution to the damped harmonic oscillator can be written as: \\[\\theta(t) = \\theta_0 e^{-\\gamma t} \\cos(\\omega_0 t + \\delta)\\] Where: \\(\\gamma = \\frac{b}{2m}\\) is the damping coefficient. The damped frequency of oscillation is: \\[\\omega_d = \\sqrt{\\omega_0^2 - \\gamma^2}\\] The amplitude of the oscillations decays as \\(e^{-\\gamma t}\\) , and for high damping, this decay leads to the cessation of motion. \ud83d\udccf Effect of Driving Amplitude \\(A\\) The driving amplitude \\(A\\) determines how much external force is applied to the system: For small \\(A\\) , the system behaves similarly to an undriven damped pendulum, with oscillations decaying over time. For large \\(A\\) , the system enters a regime where the amplitude of oscillations can grow, especially if resonance occurs. The steady-state amplitude of the pendulum's oscillations due to external forcing is given by: \\[B = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + (b\\omega)^2}}\\] As \\(A\\) increases, the system becomes more sensitive to changes in driving frequency \\(\\omega\\) , particularly near resonance. \u2699\ufe0f Effect of Driving Frequency \\(\\omega\\) The driving frequency \\(\\omega\\) determines how quickly the external force oscillates: For \\(\\omega\\) close to \\(\\omega_0\\) (resonance) , the system absorbs energy most efficiently, leading to large oscillations. For \\(\\omega\\) far from \\(\\omega_0\\) , the system experiences weaker driving forces and smaller oscillations. The resonance condition is given by: \\[\\omega_{\\text{res}} = \\sqrt{\\omega_0^2 - \\frac{b^2}{2}}\\] \ud83d\udd04 Transition Between Regular and Chaotic Motion As we vary the damping coefficient \\(b\\) , driving amplitude \\(A\\) , and driving frequency \\(\\omega\\) , the system can exhibit different types of motion: Regular Motion : For certain values of \\(A\\) and \\(\\omega\\) , the pendulum exhibits periodic, stable oscillations. This occurs especially at resonance, where the system synchronizes with the external force. Stable periodic motion can be described by a sinusoidal function: \\( \\(\\theta(t)=B\\cos(\\omega t-\\delta)\\) \\) Chaotic Motion : As \\(A\\) increases or \\(\\omega\\) deviates from resonance, the system can enter a chaotic regime , where the motion becomes irregular and sensitive to initial conditions. Chaotic systems exhibit sensitive dependence on initial conditions, meaning that even tiny differences in initial angles or velocities can lead to vastly different behaviors over time. Lyapunov exponents measure the rate of divergence of nearby trajectories in phase space. Positive Lyapunov exponents are often used to identify chaos. \ud83d\udcd0 Phase Diagrams and Poincar\u00e9 Sections To identify transitions between regular and chaotic motion, we use: Phase Diagrams : A plot of \\(\\theta\\) vs. \\(\\frac{d\\theta}{dt}\\) , which allows us to visualize the state of the system at any point in time. Poincar\u00e9 Sections : A method used to visualize the periodic or chaotic nature of the system by sampling the state of the system at periodic intervals. The transition to chaos can be observed in a bifurcation diagram , which plots the long-term behavior of the system as a function of \\(A\\) or \\(\\omega\\) . \u26a1 Physical Interpretation of Transitions Regular motion is characterized by stable periodic oscillations, where the system's energy input and dissipation are balanced. This type of motion is often seen near resonance. Chaotic motion occurs when the system's sensitivity to initial conditions becomes dominant, and small changes in \\(A\\) , \\(\\omega\\) , or initial conditions lead to unpredictable motion. This is often observed as the system\u2019s energy becomes irregularly distributed. The damping coefficient \\(b\\) determines the rate at which energy is dissipated. As \\(b\\) increases, the system is less likely to exhibit chaos, and more likely to settle into regular motion. \u2705 Summary Damping coefficient \\(b\\) influences the rate at which the system loses energy, with higher values leading to faster dissipation and lower oscillation amplitudes. Driving amplitude \\(A\\) controls the magnitude of the external force, affecting how large the oscillations can grow, especially near resonance. Driving frequency \\(\\omega\\) determines how well the system resonates with the external force, with chaos emerging as the system becomes more sensitive to variations in \\(\\omega\\) . Transitions between regular and chaotic motion depend on the interplay of these parameters. As we approach or move away from resonance, we observe different types of periodic or chaotic behavior. Investigating the Dynamics of a Forced Damped Pendulum 3. Practical Applications The dynamics of the forced damped pendulum, as studied in previous sections, can be applied to a variety of real-world systems. These systems often exhibit similar behavior, such as oscillations, damping, and the effect of external driving forces. In this section, we will explore several practical applications of the forced damped pendulum model in different fields, including energy harvesting , suspension bridges , and oscillating electronic circuits . \ud83c\udf0d Real-World Systems with Similar Dynamics Several real-world systems exhibit dynamics that closely resemble the behavior of a forced damped pendulum. These systems experience forces that cause oscillations, and the interaction of damping forces and external periodic forces results in complex behavior. Some examples include: Mechanical Systems : Mechanical oscillators, such as mass-spring systems, often demonstrate forced oscillations with damping, similar to the pendulum system. Biological Systems : Systems like human gait or the motion of the heart can be modeled using forced damped oscillators to understand rhythmic movements. Electrical Systems : Driven RLC circuits, where an external alternating current (AC) force drives the circuit, exhibit similar dynamics to the forced damped pendulum. \ud83d\udd0b Energy Harvesting Energy harvesting is the process of capturing and storing energy from environmental sources, such as vibrations, thermal gradients, or electromagnetic radiation. A common example of energy harvesting involves the use of vibrational energy harvesters , which convert mechanical vibrations into electrical energy. The forced damped pendulum model is particularly useful in designing these energy harvesters because: The driving force in an energy harvester comes from ambient vibrations, which are external periodic forces that drive oscillations in the system. The damping represents the energy dissipation due to friction or resistance in the harvester\u2019s mechanical components. The resonance condition plays a key role in maximizing the energy extraction. When the frequency of ambient vibrations matches the natural frequency of the harvester, the system oscillates with maximum amplitude, allowing for the most efficient conversion of mechanical energy into electrical energy. The power extracted from the system can be modeled as: \\[ P = \\frac{1}{2} m L^2 \\left(\\frac{d\\theta}{dt}\\right)^2 \\] Where: \\(P\\) is the power extracted from the system. \\(m\\) is the mass of the pendulum. \\(L\\) is the length of the pendulum. \\(\\theta(t)\\) is the angular displacement as a function of time. \ud83c\udf09 Suspension Bridges Suspension bridges are large, flexible structures that are susceptible to oscillations due to external forces, such as wind or traffic loads. The dynamics of the forced damped pendulum model can be applied to understand the oscillations of suspension bridges, particularly when considering: External driving forces , such as wind gusts or traffic-induced vibrations, that act as periodic forces on the bridge. Damping from the bridge\u2019s material properties, as well as from the air resistance and other frictional forces that act on the structure. Resonance between the natural frequency of the bridge and the driving frequency (e.g., wind), which can lead to large oscillations if not properly managed. In suspension bridges, resonance can be dangerous, as it can lead to large-amplitude oscillations, potentially causing structural failure. The Tacoma Narrows Bridge collapse in 1940 is a famous example of resonance-induced failure. The bridge\u2019s motion can be modeled by: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = F_{\\text{ext}}(t) \\] Where: \\(\\theta(t)\\) is the angular displacement of the bridge. \\(F_{\\text{ext}}(t)\\) is the external periodic driving force (e.g., wind). \\(b\\) is the damping coefficient related to the air resistance and friction. By controlling the damping coefficient and avoiding resonance, engineers can reduce the risk of catastrophic failure in suspension bridges. \ud83d\udca1 Oscillating Electronic Circuits In electronics, RLC circuits (Resistor, Inductor, Capacitor) are commonly used to model oscillations in driven systems. A forced damped pendulum can be applied to analyze these circuits, as they exhibit similar dynamics: Driving Force : In an RLC circuit, the external driving force is the alternating current (AC) voltage that drives the system. Damping : Damping in RLC circuits is represented by the resistance \\(R\\) , which dissipates energy. Resonance : Just like in the pendulum, the circuit exhibits resonance when the driving frequency matches the natural frequency of the LC circuit. The behavior of an RLC circuit under external driving forces can be described by the following equation: \\[ L \\frac{d^2 q}{dt^2} + R \\frac{dq}{dt} + \\frac{1}{C} q = V_{\\text{ext}}(t) \\] Where: \\(q(t)\\) is the charge on the capacitor. \\(V_{\\text{ext}}(t)\\) is the external driving voltage. \\(L\\) is the inductance of the coil. \\(C\\) is the capacitance of the capacitor. \\(R\\) is the resistance of the circuit. At resonance, the current in the circuit can become very large, leading to potential damage if not properly controlled. The forced damped pendulum model can be used to predict and mitigate these effects by adjusting the driving frequency and damping characteristics. \u2705 Summary Energy Harvesting : The forced damped pendulum model helps design efficient vibrational energy harvesters by maximizing energy extraction at resonance. Suspension Bridges : Understanding resonance and damping in suspension bridges can prevent large amplitude oscillations and avoid structural failure due to external driving forces like wind. Oscillating Electronic Circuits : The model can also be applied to RLC circuits, where external AC voltages drive oscillations, and resonance must be carefully controlled to avoid damage. In all these systems, the principles of forced oscillations, damping, and resonance play critical roles in ensuring proper functionality and avoiding failure. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Common parameters g = 9.81 # gravitational acceleration (m/s\u00b2) L = 1.0 # pendulum length (m) theta0 = 0.2 # small initial angle (radians) omega0 = 0.0 # initial angular velocity (rad/s) y0 = [theta0, omega0] t_span = (0, 20) t_eval = np.linspace(t_span[0], t_span[1], 1000) # 1) Simple Pendulum (b = 0, A = 0) def simple_pendulum(t, y): theta, omega = y dydt = [omega, -(g / L) * np.sin(theta)] return dydt sol_simple = solve_ivp(simple_pendulum, t_span, y0, t_eval=t_eval) # 2) Damped Pendulum (b != 0, A = 0) b = 0.2 # damping coefficient def damped_pendulum(t, y): theta, omega = y dydt = [omega, -b * omega - (g / L) * np.sin(theta)] return dydt sol_damped = solve_ivp(damped_pendulum, t_span, y0, t_eval=t_eval) # 3) Forced Pendulum (b = 0, A != 0) A = 0.5 # driving force amplitude omega_drive = 2/3 # driving frequency def forced_pendulum(t, y): theta, omega = y dydt = [omega, -(g / L) * np.sin(theta) + A * np.cos(omega_drive * t)] return dydt sol_forced = solve_ivp(forced_pendulum, t_span, y0, t_eval=t_eval) # Function to plot one pendulum case (time series + phase portrait) def plot_case(sol, case_title, color): theta = sol.y[0] omega = sol.y[1] t = sol.t fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4)) # Time series ax1.plot(t, theta, color=color, linewidth=1) ax1.set_xlabel('Time (s)') ax1.set_ylabel('Theta (rad)') ax1.set_title('Time Series') ax1.grid(True) # Phase portrait ax2.plot(theta, omega, color=color, linewidth=1) ax2.set_xlabel('Theta (rad)') ax2.set_ylabel('Omega (rad/s)') ax2.set_title('Phase Portrait') ax2.grid(True) # Main title fig.suptitle(case_title, fontsize=16, color=color) plt.tight_layout() plt.subplots_adjust(top=0.8) # Adjust to fit main title plt.show() # --- Now plot each system separately --- plot_case(sol_simple, \"1) Simple Pendulum\", 'red') plot_case(sol_damped, \"2) Damped Pendulum\", 'blue') plot_case(sol_forced, \"3) Forced Pendulum\", 'teal') import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Common parameters g = 9.81 # gravitational acceleration (m/s\u00b2) L = 1.0 # pendulum length (m) theta0 = 0.2 # initial angle (radians) omega0 = 0.0 # initial angular velocity (rad/s) y0 = [theta0, omega0] t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 2000) # Function to define forced, damped pendulum def forced_damped_pendulum(t, y, b, A, omega_drive): theta, omega = y dydt = [omega, -b * omega - (g / L) * np.sin(theta) + A * np.cos(omega_drive * t)] return dydt # Scenario 1: Mild damping, moderate forcing b1 = 0.1 A1 = 0.5 omega_drive1 = 2/3 sol1 = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b1, A1, omega_drive1)) # Scenario 2: Stronger damping, stronger forcing b2 = 0.5 A2 = 1.2 omega_drive2 = 2/3 sol2 = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b2, A2, omega_drive2)) # Plotting function def plot_forced_damped(sol, title, color): theta = sol.y[0] omega = sol.y[1] t = sol.t fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5)) # Time series ax1.plot(t, theta, color=color, linewidth=1) ax1.set_xlabel('Time (s)') ax1.set_ylabel('Theta (rad)') ax1.set_title('Time Series') ax1.grid(True) # Phase portrait ax2.plot(theta, omega, color=color, linewidth=1) ax2.set_xlabel('Theta (rad)') ax2.set_ylabel('Omega (rad/s)') ax2.set_title('Phase Portrait') ax2.grid(True) fig.suptitle(title, fontsize=16, color=color) plt.tight_layout() plt.subplots_adjust(top=0.85) plt.show() # Plot both scenarios plot_forced_damped(sol1, \"Scenario 1: Mild Damping, Moderate Forcing\", 'purple') plot_forced_damped(sol2, \"Scenario 2: Strong Damping, Strong Forcing\", 'darkorange') import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equations def forced_damped_pendulum(t, y, gamma, omega0, A, omega): theta, omega_t = y dtheta_dt = omega_t domega_dt = -gamma * omega_t - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.0 # Natural frequency A = 1.2 # Forcing amplitude omega = 2.0 # Forcing frequency # Initial conditions and time span t_span = (0, 50) y0 = [0.2, 0] # Initial angle and angular velocity t_eval = np.linspace(0, 50, 1000) # Solve the ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(gamma, omega0, A, omega)) # Plot results plt.figure(figsize=(10,5)) plt.plot(sol.t, sol.y[0], label=\"Theta (angle)\") plt.xlabel(\"Time\") plt.ylabel(\"Angle (radians)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show() plt.figure(figsize=(8, 4)) sol = solve_ivp(damped_pendulum, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=\"Damped Pendulum\", color='orange') plt.title(\"2. Damped Pendulum\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() plt.figure(figsize=(8, 4)) sol = solve_ivp(forced_pendulum, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=\"Forced Pendulum\", color='green') plt.title(\"3. Forced Pendulum\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() plt.figure(figsize=(8, 4)) sol = solve_ivp(forced_damped_1, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=\"Forced Damped - Scenario 1\", color='red') plt.title(\"4. Forced Damped Pendulum - Scenario 1\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() plt.figure(figsize=(8, 4)) sol = solve_ivp(forced_damped_2, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=\"Forced Damped - Scenario 2\", color='purple') plt.title(\"5. Forced Damped Pendulum - Scenario 2\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Common parameters g = 9.81 l = 1.0 gamma = 0.1 A1 = 0.5 A2 = 1.2 w1 = 2.0 w2 = 3.5 t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) theta0 = [np.pi / 4, 0] # initial [theta, omega] # Phase plot function def phase_plot(system_func, title): sol = solve_ivp(system_func, t_span, theta0, t_eval=t_eval) theta = sol.y[0] omega = sol.y[1] plt.figure(figsize=(6, 5)) plt.plot(theta, omega, label=title) plt.title(title + \" - Phase Diagram\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular Velocity \u03c9 (rad/s)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() # 1. Simple Pendulum def simple_pendulum(t, y): return [y[1], - (g / l) * np.sin(y[0])] phase_plot(simple_pendulum, \"1. Simple Pendulum\") # 2. Damped Pendulum def damped_pendulum(t, y): return [y[1], -gamma * y[1] - (g / l) * np.sin(y[0])] phase_plot(damped_pendulum, \"2. Damped Pendulum\") # 3. Forced Pendulum def forced_pendulum(t, y): return [y[1], - (g / l) * np.sin(y[0]) + A1 * np.cos(w1 * t)] phase_plot(forced_pendulum, \"3. Forced Pendulum\") # 4. Forced Damped Pendulum - Scenario 1 def forced_damped_1(t, y): return [y[1], -gamma * y[1] - (g / l) * np.sin(y[0]) + A1 * np.cos(w1 * t)] phase_plot(forced_damped_1, \"4. Forced Damped - Scenario 1\") # 5. Forced Damped Pendulum - Scenario 2 def forced_damped_2(t, y): return [y[1], -0.05 * y[1] - (g / l) * np.sin(y[0]) + A2 * np.cos(w2 * t)] phase_plot(forced_damped_2, \"5. Forced Damped - Scenario 2\")","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The forced damped pendulum is governed by a second-order nonlinear ordinary differential equation (ODE) that models the angular displacement of a pendulum subjected to both damping and an external periodic force.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-differential-equation","text":"The general equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] Where: \\(\\theta(t)\\) : Angular displacement as a function of time \\(b\\) : Damping coefficient \\(g\\) : Acceleration due to gravity \\(L\\) : Length of the pendulum \\(A\\) : Amplitude of the external driving force \\(\\omega\\) : Angular frequency of the driving force he driving force","title":"\ud83d\udccc Governing Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"Under the small-angle approximation (where \\(\\theta \\ll 1\\) ), we can linearize the sine function as follows: \\[\\sin\\theta \\approx \\theta\\] This simplification reduces the governing equation to a linear inhomogeneous ordinary differential equation (ODE) : \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t)\\]","title":"\ud83d\udd0d Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analytical-solution-for-small-angles","text":"The general solution to the linearized ODE consists of two parts: Homogeneous solution (related to natural damping): \\( \\(\\theta_h(t)=C_1e^{r_1t}+C_2e^{r_2t}\\) \\) where \\(r_1,r_2\\) are roots of the characteristic equation: \\( \\(r^2+br+\\frac{g}{L}=0\\) \\) Particular solution (related to the external forcing): We assume a steady-state solution of the form: \\[\\theta_p(t)=B\\cos(\\omega t-\\delta)\\] where: The amplitude of the forced oscillation is denoted by \\(B\\) , and the phase lag due to damping is denoted by \\(\\delta\\) . The amplitude of the steady-state response is given by: \\[B=\\frac{A}{\\sqrt{\\left(\\frac{g}{L}-\\omega^2\\right)^2+(b\\omega)^2}}\\]","title":"\ud83d\udcd0 Analytical Solution for Small Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Resonance occurs when the driving frequency \\(\\omega\\) approaches the natural frequency of the system: \\[ \\omega_0=\\sqrt{\\frac{g}{L}} \\] At resonance, the system absorbs energy most efficiently from the external force, and the amplitude \\(B\\) reaches a maximum: Without damping ( \\(b=0\\) ): \\[ B\\to\\infty\\quad\\text{as}\\quad\\omega\\to\\omega_0 \\] With damping: \\[ B_{\\text{max}}=\\frac{A}{b\\omega_0} \\] This finite maximum occurs at a slightly shifted resonance frequency: \\[ \\omega_{\\text{res}}=\\sqrt{\\omega_0^2-\\frac{b^2}{2}} \\]","title":"\ud83c\udfaf Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-behavior-at-resonance","text":"The total mechanical energy of the pendulum is the sum of kinetic and potential energy: \\[ E(t) = \\frac{1}{2} m L^2 \\left(\\frac{d\\theta}{dt}\\right)^2 + mgL(1 - \\cos\\theta) \\] Under resonance: The system continually absorbs energy from the external force. The kinetic energy grows in the undamped case. In the damped case, energy input is balanced by dissipation: Leads to a steady-state oscillation. The energy oscillates but remains bounded.","title":"\u26a1 Energy Behavior at Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary","text":"The equation of motion combines restoring, damping, and external driving forces. Linearization using \\(\\sin\\theta \\approx \\theta\\) simplifies the analysis for small oscillations. Resonance amplifies oscillation amplitudes and affects energy flow. Damping ensures bounded energy growth even at resonance.","title":"\u2705 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum_1","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"In this section, we will investigate how the dynamics of the forced damped pendulum are influenced by key parameters such as the damping coefficient \\(b\\) , driving amplitude \\(A\\) , and driving frequency \\(\\omega\\) . Additionally, we will explore the transition between regular motion and chaotic behavior , and interpret the physical meaning of these transitions.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-damping-coefficient-b","text":"The damping coefficient \\(b\\) plays a crucial role in determining the behavior of the system: For low damping ( \\(b \\to 0\\) ), the pendulum oscillates with large amplitudes, and the system is primarily influenced by the restoring force and external periodic force. For high damping ( \\(b \\to \\infty\\) ), the pendulum quickly returns to rest, and the oscillations decay exponentially. Mathematically, the solution to the damped harmonic oscillator can be written as: \\[\\theta(t) = \\theta_0 e^{-\\gamma t} \\cos(\\omega_0 t + \\delta)\\] Where: \\(\\gamma = \\frac{b}{2m}\\) is the damping coefficient. The damped frequency of oscillation is: \\[\\omega_d = \\sqrt{\\omega_0^2 - \\gamma^2}\\] The amplitude of the oscillations decays as \\(e^{-\\gamma t}\\) , and for high damping, this decay leads to the cessation of motion.","title":"\ud83d\udcca Effect of Damping Coefficient \\(b\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-driving-amplitude-a","text":"The driving amplitude \\(A\\) determines how much external force is applied to the system: For small \\(A\\) , the system behaves similarly to an undriven damped pendulum, with oscillations decaying over time. For large \\(A\\) , the system enters a regime where the amplitude of oscillations can grow, especially if resonance occurs. The steady-state amplitude of the pendulum's oscillations due to external forcing is given by: \\[B = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + (b\\omega)^2}}\\] As \\(A\\) increases, the system becomes more sensitive to changes in driving frequency \\(\\omega\\) , particularly near resonance.","title":"\ud83d\udccf Effect of Driving Amplitude \\(A\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-driving-frequency-omega","text":"The driving frequency \\(\\omega\\) determines how quickly the external force oscillates: For \\(\\omega\\) close to \\(\\omega_0\\) (resonance) , the system absorbs energy most efficiently, leading to large oscillations. For \\(\\omega\\) far from \\(\\omega_0\\) , the system experiences weaker driving forces and smaller oscillations. The resonance condition is given by: \\[\\omega_{\\text{res}} = \\sqrt{\\omega_0^2 - \\frac{b^2}{2}}\\]","title":"\u2699\ufe0f Effect of Driving Frequency \\(\\omega\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-between-regular-and-chaotic-motion","text":"As we vary the damping coefficient \\(b\\) , driving amplitude \\(A\\) , and driving frequency \\(\\omega\\) , the system can exhibit different types of motion: Regular Motion : For certain values of \\(A\\) and \\(\\omega\\) , the pendulum exhibits periodic, stable oscillations. This occurs especially at resonance, where the system synchronizes with the external force. Stable periodic motion can be described by a sinusoidal function: \\( \\(\\theta(t)=B\\cos(\\omega t-\\delta)\\) \\) Chaotic Motion : As \\(A\\) increases or \\(\\omega\\) deviates from resonance, the system can enter a chaotic regime , where the motion becomes irregular and sensitive to initial conditions. Chaotic systems exhibit sensitive dependence on initial conditions, meaning that even tiny differences in initial angles or velocities can lead to vastly different behaviors over time. Lyapunov exponents measure the rate of divergence of nearby trajectories in phase space. Positive Lyapunov exponents are often used to identify chaos.","title":"\ud83d\udd04 Transition Between Regular and Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-diagrams-and-poincare-sections","text":"To identify transitions between regular and chaotic motion, we use: Phase Diagrams : A plot of \\(\\theta\\) vs. \\(\\frac{d\\theta}{dt}\\) , which allows us to visualize the state of the system at any point in time. Poincar\u00e9 Sections : A method used to visualize the periodic or chaotic nature of the system by sampling the state of the system at periodic intervals. The transition to chaos can be observed in a bifurcation diagram , which plots the long-term behavior of the system as a function of \\(A\\) or \\(\\omega\\) .","title":"\ud83d\udcd0 Phase Diagrams and Poincar\u00e9 Sections"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#physical-interpretation-of-transitions","text":"Regular motion is characterized by stable periodic oscillations, where the system's energy input and dissipation are balanced. This type of motion is often seen near resonance. Chaotic motion occurs when the system's sensitivity to initial conditions becomes dominant, and small changes in \\(A\\) , \\(\\omega\\) , or initial conditions lead to unpredictable motion. This is often observed as the system\u2019s energy becomes irregularly distributed. The damping coefficient \\(b\\) determines the rate at which energy is dissipated. As \\(b\\) increases, the system is less likely to exhibit chaos, and more likely to settle into regular motion.","title":"\u26a1 Physical Interpretation of Transitions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary_1","text":"Damping coefficient \\(b\\) influences the rate at which the system loses energy, with higher values leading to faster dissipation and lower oscillation amplitudes. Driving amplitude \\(A\\) controls the magnitude of the external force, affecting how large the oscillations can grow, especially near resonance. Driving frequency \\(\\omega\\) determines how well the system resonates with the external force, with chaos emerging as the system becomes more sensitive to variations in \\(\\omega\\) . Transitions between regular and chaotic motion depend on the interplay of these parameters. As we approach or move away from resonance, we observe different types of periodic or chaotic behavior.","title":"\u2705 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum_2","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The dynamics of the forced damped pendulum, as studied in previous sections, can be applied to a variety of real-world systems. These systems often exhibit similar behavior, such as oscillations, damping, and the effect of external driving forces. In this section, we will explore several practical applications of the forced damped pendulum model in different fields, including energy harvesting , suspension bridges , and oscillating electronic circuits .","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#real-world-systems-with-similar-dynamics","text":"Several real-world systems exhibit dynamics that closely resemble the behavior of a forced damped pendulum. These systems experience forces that cause oscillations, and the interaction of damping forces and external periodic forces results in complex behavior. Some examples include: Mechanical Systems : Mechanical oscillators, such as mass-spring systems, often demonstrate forced oscillations with damping, similar to the pendulum system. Biological Systems : Systems like human gait or the motion of the heart can be modeled using forced damped oscillators to understand rhythmic movements. Electrical Systems : Driven RLC circuits, where an external alternating current (AC) force drives the circuit, exhibit similar dynamics to the forced damped pendulum.","title":"\ud83c\udf0d Real-World Systems with Similar Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-harvesting","text":"Energy harvesting is the process of capturing and storing energy from environmental sources, such as vibrations, thermal gradients, or electromagnetic radiation. A common example of energy harvesting involves the use of vibrational energy harvesters , which convert mechanical vibrations into electrical energy. The forced damped pendulum model is particularly useful in designing these energy harvesters because: The driving force in an energy harvester comes from ambient vibrations, which are external periodic forces that drive oscillations in the system. The damping represents the energy dissipation due to friction or resistance in the harvester\u2019s mechanical components. The resonance condition plays a key role in maximizing the energy extraction. When the frequency of ambient vibrations matches the natural frequency of the harvester, the system oscillates with maximum amplitude, allowing for the most efficient conversion of mechanical energy into electrical energy. The power extracted from the system can be modeled as: \\[ P = \\frac{1}{2} m L^2 \\left(\\frac{d\\theta}{dt}\\right)^2 \\] Where: \\(P\\) is the power extracted from the system. \\(m\\) is the mass of the pendulum. \\(L\\) is the length of the pendulum. \\(\\theta(t)\\) is the angular displacement as a function of time.","title":"\ud83d\udd0b Energy Harvesting"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#suspension-bridges","text":"Suspension bridges are large, flexible structures that are susceptible to oscillations due to external forces, such as wind or traffic loads. The dynamics of the forced damped pendulum model can be applied to understand the oscillations of suspension bridges, particularly when considering: External driving forces , such as wind gusts or traffic-induced vibrations, that act as periodic forces on the bridge. Damping from the bridge\u2019s material properties, as well as from the air resistance and other frictional forces that act on the structure. Resonance between the natural frequency of the bridge and the driving frequency (e.g., wind), which can lead to large oscillations if not properly managed. In suspension bridges, resonance can be dangerous, as it can lead to large-amplitude oscillations, potentially causing structural failure. The Tacoma Narrows Bridge collapse in 1940 is a famous example of resonance-induced failure. The bridge\u2019s motion can be modeled by: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = F_{\\text{ext}}(t) \\] Where: \\(\\theta(t)\\) is the angular displacement of the bridge. \\(F_{\\text{ext}}(t)\\) is the external periodic driving force (e.g., wind). \\(b\\) is the damping coefficient related to the air resistance and friction. By controlling the damping coefficient and avoiding resonance, engineers can reduce the risk of catastrophic failure in suspension bridges.","title":"\ud83c\udf09 Suspension Bridges"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#oscillating-electronic-circuits","text":"In electronics, RLC circuits (Resistor, Inductor, Capacitor) are commonly used to model oscillations in driven systems. A forced damped pendulum can be applied to analyze these circuits, as they exhibit similar dynamics: Driving Force : In an RLC circuit, the external driving force is the alternating current (AC) voltage that drives the system. Damping : Damping in RLC circuits is represented by the resistance \\(R\\) , which dissipates energy. Resonance : Just like in the pendulum, the circuit exhibits resonance when the driving frequency matches the natural frequency of the LC circuit. The behavior of an RLC circuit under external driving forces can be described by the following equation: \\[ L \\frac{d^2 q}{dt^2} + R \\frac{dq}{dt} + \\frac{1}{C} q = V_{\\text{ext}}(t) \\] Where: \\(q(t)\\) is the charge on the capacitor. \\(V_{\\text{ext}}(t)\\) is the external driving voltage. \\(L\\) is the inductance of the coil. \\(C\\) is the capacitance of the capacitor. \\(R\\) is the resistance of the circuit. At resonance, the current in the circuit can become very large, leading to potential damage if not properly controlled. The forced damped pendulum model can be used to predict and mitigate these effects by adjusting the driving frequency and damping characteristics.","title":"\ud83d\udca1 Oscillating Electronic Circuits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary_2","text":"Energy Harvesting : The forced damped pendulum model helps design efficient vibrational energy harvesters by maximizing energy extraction at resonance. Suspension Bridges : Understanding resonance and damping in suspension bridges can prevent large amplitude oscillations and avoid structural failure due to external driving forces like wind. Oscillating Electronic Circuits : The model can also be applied to RLC circuits, where external AC voltages drive oscillations, and resonance must be carefully controlled to avoid damage. In all these systems, the principles of forced oscillations, damping, and resonance play critical roles in ensuring proper functionality and avoiding failure.","title":"\u2705 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Common parameters g = 9.81 # gravitational acceleration (m/s\u00b2) L = 1.0 # pendulum length (m) theta0 = 0.2 # small initial angle (radians) omega0 = 0.0 # initial angular velocity (rad/s) y0 = [theta0, omega0] t_span = (0, 20) t_eval = np.linspace(t_span[0], t_span[1], 1000) # 1) Simple Pendulum (b = 0, A = 0) def simple_pendulum(t, y): theta, omega = y dydt = [omega, -(g / L) * np.sin(theta)] return dydt sol_simple = solve_ivp(simple_pendulum, t_span, y0, t_eval=t_eval) # 2) Damped Pendulum (b != 0, A = 0) b = 0.2 # damping coefficient def damped_pendulum(t, y): theta, omega = y dydt = [omega, -b * omega - (g / L) * np.sin(theta)] return dydt sol_damped = solve_ivp(damped_pendulum, t_span, y0, t_eval=t_eval) # 3) Forced Pendulum (b = 0, A != 0) A = 0.5 # driving force amplitude omega_drive = 2/3 # driving frequency def forced_pendulum(t, y): theta, omega = y dydt = [omega, -(g / L) * np.sin(theta) + A * np.cos(omega_drive * t)] return dydt sol_forced = solve_ivp(forced_pendulum, t_span, y0, t_eval=t_eval) # Function to plot one pendulum case (time series + phase portrait) def plot_case(sol, case_title, color): theta = sol.y[0] omega = sol.y[1] t = sol.t fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4)) # Time series ax1.plot(t, theta, color=color, linewidth=1) ax1.set_xlabel('Time (s)') ax1.set_ylabel('Theta (rad)') ax1.set_title('Time Series') ax1.grid(True) # Phase portrait ax2.plot(theta, omega, color=color, linewidth=1) ax2.set_xlabel('Theta (rad)') ax2.set_ylabel('Omega (rad/s)') ax2.set_title('Phase Portrait') ax2.grid(True) # Main title fig.suptitle(case_title, fontsize=16, color=color) plt.tight_layout() plt.subplots_adjust(top=0.8) # Adjust to fit main title plt.show() # --- Now plot each system separately --- plot_case(sol_simple, \"1) Simple Pendulum\", 'red') plot_case(sol_damped, \"2) Damped Pendulum\", 'blue') plot_case(sol_forced, \"3) Forced Pendulum\", 'teal')","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_2","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Common parameters g = 9.81 # gravitational acceleration (m/s\u00b2) L = 1.0 # pendulum length (m) theta0 = 0.2 # initial angle (radians) omega0 = 0.0 # initial angular velocity (rad/s) y0 = [theta0, omega0] t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 2000) # Function to define forced, damped pendulum def forced_damped_pendulum(t, y, b, A, omega_drive): theta, omega = y dydt = [omega, -b * omega - (g / L) * np.sin(theta) + A * np.cos(omega_drive * t)] return dydt # Scenario 1: Mild damping, moderate forcing b1 = 0.1 A1 = 0.5 omega_drive1 = 2/3 sol1 = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b1, A1, omega_drive1)) # Scenario 2: Stronger damping, stronger forcing b2 = 0.5 A2 = 1.2 omega_drive2 = 2/3 sol2 = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b2, A2, omega_drive2)) # Plotting function def plot_forced_damped(sol, title, color): theta = sol.y[0] omega = sol.y[1] t = sol.t fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5)) # Time series ax1.plot(t, theta, color=color, linewidth=1) ax1.set_xlabel('Time (s)') ax1.set_ylabel('Theta (rad)') ax1.set_title('Time Series') ax1.grid(True) # Phase portrait ax2.plot(theta, omega, color=color, linewidth=1) ax2.set_xlabel('Theta (rad)') ax2.set_ylabel('Omega (rad/s)') ax2.set_title('Phase Portrait') ax2.grid(True) fig.suptitle(title, fontsize=16, color=color) plt.tight_layout() plt.subplots_adjust(top=0.85) plt.show() # Plot both scenarios plot_forced_damped(sol1, \"Scenario 1: Mild Damping, Moderate Forcing\", 'purple') plot_forced_damped(sol2, \"Scenario 2: Strong Damping, Strong Forcing\", 'darkorange')","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_3","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equations def forced_damped_pendulum(t, y, gamma, omega0, A, omega): theta, omega_t = y dtheta_dt = omega_t domega_dt = -gamma * omega_t - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.0 # Natural frequency A = 1.2 # Forcing amplitude omega = 2.0 # Forcing frequency # Initial conditions and time span t_span = (0, 50) y0 = [0.2, 0] # Initial angle and angular velocity t_eval = np.linspace(0, 50, 1000) # Solve the ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(gamma, omega0, A, omega)) # Plot results plt.figure(figsize=(10,5)) plt.plot(sol.t, sol.y[0], label=\"Theta (angle)\") plt.xlabel(\"Time\") plt.ylabel(\"Angle (radians)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_4","text":"plt.figure(figsize=(8, 4)) sol = solve_ivp(damped_pendulum, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=\"Damped Pendulum\", color='orange') plt.title(\"2. Damped Pendulum\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_5","text":"plt.figure(figsize=(8, 4)) sol = solve_ivp(forced_pendulum, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=\"Forced Pendulum\", color='green') plt.title(\"3. Forced Pendulum\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_6","text":"plt.figure(figsize=(8, 4)) sol = solve_ivp(forced_damped_1, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=\"Forced Damped - Scenario 1\", color='red') plt.title(\"4. Forced Damped Pendulum - Scenario 1\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_7","text":"plt.figure(figsize=(8, 4)) sol = solve_ivp(forced_damped_2, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=\"Forced Damped - Scenario 2\", color='purple') plt.title(\"5. Forced Damped Pendulum - Scenario 2\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_8","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Common parameters g = 9.81 l = 1.0 gamma = 0.1 A1 = 0.5 A2 = 1.2 w1 = 2.0 w2 = 3.5 t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) theta0 = [np.pi / 4, 0] # initial [theta, omega] # Phase plot function def phase_plot(system_func, title): sol = solve_ivp(system_func, t_span, theta0, t_eval=t_eval) theta = sol.y[0] omega = sol.y[1] plt.figure(figsize=(6, 5)) plt.plot(theta, omega, label=title) plt.title(title + \" - Phase Diagram\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular Velocity \u03c9 (rad/s)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() # 1. Simple Pendulum def simple_pendulum(t, y): return [y[1], - (g / l) * np.sin(y[0])] phase_plot(simple_pendulum, \"1. Simple Pendulum\") # 2. Damped Pendulum def damped_pendulum(t, y): return [y[1], -gamma * y[1] - (g / l) * np.sin(y[0])] phase_plot(damped_pendulum, \"2. Damped Pendulum\") # 3. Forced Pendulum def forced_pendulum(t, y): return [y[1], - (g / l) * np.sin(y[0]) + A1 * np.cos(w1 * t)] phase_plot(forced_pendulum, \"3. Forced Pendulum\") # 4. Forced Damped Pendulum - Scenario 1 def forced_damped_1(t, y): return [y[1], -gamma * y[1] - (g / l) * np.sin(y[0]) + A1 * np.cos(w1 * t)] phase_plot(forced_damped_1, \"4. Forced Damped - Scenario 1\") # 5. Forced Damped Pendulum - Scenario 2 def forced_damped_2(t, y): return [y[1], -0.05 * y[1] - (g / l) * np.sin(y[0]) + A2 * np.cos(w2 * t)] phase_plot(forced_damped_2, \"5. Forced Damped - Scenario 2\")","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Gravity Problem 1: Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. It connects orbital dynamics to gravitational forces Crucial for: Determining planetary motion Designing satellite trajectories Estimating masses of celestial objects Task Derive the relationship between: Orbital period \\(T\\) Orbital radius \\(r\\) Use Newton's Law of Gravitation and centripetal force Apply the law to real-world cases like: Moon's orbit around Earth Planets in the Solar System Simulate circular orbits to verify the relation Derivation Step 1: Newton's Law of Universal Gravitation \\[F_g = \\frac{GMm}{r^2}\\] Step 2: Centripetal Force Required for Circular Motion \\[F_c = \\frac{mv^2}{r}\\] Equating gravitational force and centripetal force : \\[\\frac{GMm}{r^2} = \\frac{mv^2}{r}\\] Cancel \\(m\\) and rearrange: \\[v^2 = \\frac{GM}{r}\\] Step 3: Express velocity in terms of period \\(T\\) Orbital speed \\(v = \\frac{2\\pi r}{T}\\) Substitute into the equation: \\[\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{GM}{r}\\] Expand and simplify: \\[\\frac{4\\pi^2 r^2}{T^2} = \\frac{GM}{r}\\] Multiply both sides by \\(T^2 r\\) : \\[4\\pi^2 r^3 = GMT^2\\] Finally: \\[T^2 = \\frac{4\\pi^2}{GM} r^3\\] Sure! Here's a short academic-style note summarizing what was done: \ud83d\udcd8 Summary Note: Estimating Mass of Earth and Sun Using Kepler\u2019s Third Law This document provides a manual derivation and computation of the mass of the Earth and the Sun using Kepler's Third Law : We used the formula: $$ M = \\frac{4\\pi^2 r^3}{G T^2} $$ which relates a satellite\u2019s orbital period ($T$) and radius ($r$) to the central body's mass ($M$). For the Earth , we used: Orbital altitude of 400 km, Period $T = 5400$ s, Earth radius $R = 6.371 \\times 10^6$ m, Result: \\(M_{Earth} \\approx 6.32 \\times 10^{24}\\ \\text{kg}\\) For the Sun , we used: Earth-Sun distance: $1.496 \\times 10^{11}$ m, Period $T = 1$ year, Result: \\(M_{Sun} \\approx 1.99 \\times 10^{30}\\ \\text{kg}\\) Implications Kepler's Third Law : \\(T^2 \\propto r^3\\) This relation: Helps determine the mass of the central object Predicts motion of satellites and moons Useful for astro-navigation and space missions Real-World Example: The Moon Mass of Earth: \\(M = 5.97 \\times 10^{24}\\) kg Radius of Moon's orbit: \\(r = 3.84 \\times 10^8\\) m Using: \\[T = 2\\pi \\sqrt{\\frac{r^3}{GM}}\\] Python Simulation import numpy as np import matplotlib.pyplot as plt import pandas as pd planets = { 'Mercury': {'r': 57.9e6, 'T': 0.241}, 'Venus': {'r': 108.2e6, 'T': 0.615}, 'Earth': {'r': 149.6e6, 'T': 1.000}, 'Mars': {'r': 227.9e6, 'T': 1.881} } data = { 'Planet': [], 'r (10^6 km)': [], 'T (years)': [], 'r\u00b3 (10^18 km\u00b3)': [], 'T\u00b2 (years\u00b2)': [] } for name, values in planets.items(): r = values['r'] T = values['T'] data['Planet'].append(name) data['r (10^6 km)'].append(r) data['T (years)'].append(T) data['r\u00b3 (10^18 km\u00b3)'].append((r**3) / 1e18) data['T\u00b2 (years\u00b2)'].append(T**2) df = pd.DataFrame(data) print(df) plt.plot(df['r\u00b3 (10^18 km\u00b3)'], df['T\u00b2 (years\u00b2)'], 'ro-', markersize=8) for i, txt in enumerate(df['Planet']): plt.annotate(txt, (df['r\u00b3 (10^18 km\u00b3)'][i], df['T\u00b2 (years\u00b2)'][i]), textcoords=\"offset points\", xytext=(5,5), ha='center') plt.xlabel(r'$r^3$ (in $10^{18}\\ km^3$)') plt.ylabel(r'$T^2$ (in $years^2$)') plt.title('Verification of Kepler\\'s Third Law with Solar System Planets') plt.grid(True) plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Orbital parameters (in astronomical units and years) radius = 1 # Orbital radius in AU period = 1 # Orbital period in years omega = 2 * np.pi / period # Angular velocity (rad/year) # Time array (convert years to days) t = np.linspace(0, period, 360) x = radius * np.cos(omega * t * 365) # X-position over time y = radius * np.sin(omega * t * 365) # Y-position over time # Set up the figure and axis fig, ax = plt.subplots(figsize=(6, 6)) ax.set_aspect('equal') ax.set_xlim(-1.5, 1.5) ax.set_ylim(-1.5, 1.5) ax.set_title(\"Circular Planet Orbit (Kepler's 3rd Law)\") ax.set_xlabel(\"X (AU)\") ax.set_ylabel(\"Y (AU)\") # Draw the Sun and initialize the planet sun = plt.Circle((0, 0), 0.05, color='gold', label='Sun') planet, = plt.plot([], [], 'o', color='blue', label='Planet') orbit, = plt.plot(x, y, linestyle='dotted', color='gray', alpha=0.5) # Add the Sun to the plot ax.add_artist(sun) ax.legend(loc=\"upper right\") # Animation update function def update(frame): # Modified to provide sequences to set_data planet.set_data([x[frame]], [y[frame]]) return planet, # Create animation ani = FuncAnimation(fig, update, frames=len(t), interval=30, blit=True) plt.show()","title":"Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity","text":"","title":"Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"","title":"Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. It connects orbital dynamics to gravitational forces Crucial for: Determining planetary motion Designing satellite trajectories Estimating masses of celestial objects","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task","text":"Derive the relationship between: Orbital period \\(T\\) Orbital radius \\(r\\) Use Newton's Law of Gravitation and centripetal force Apply the law to real-world cases like: Moon's orbit around Earth Planets in the Solar System Simulate circular orbits to verify the relation","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation","text":"Step 1: Newton's Law of Universal Gravitation \\[F_g = \\frac{GMm}{r^2}\\] Step 2: Centripetal Force Required for Circular Motion \\[F_c = \\frac{mv^2}{r}\\] Equating gravitational force and centripetal force : \\[\\frac{GMm}{r^2} = \\frac{mv^2}{r}\\] Cancel \\(m\\) and rearrange: \\[v^2 = \\frac{GM}{r}\\] Step 3: Express velocity in terms of period \\(T\\) Orbital speed \\(v = \\frac{2\\pi r}{T}\\) Substitute into the equation: \\[\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{GM}{r}\\] Expand and simplify: \\[\\frac{4\\pi^2 r^2}{T^2} = \\frac{GM}{r}\\] Multiply both sides by \\(T^2 r\\) : \\[4\\pi^2 r^3 = GMT^2\\] Finally: \\[T^2 = \\frac{4\\pi^2}{GM} r^3\\] Sure! Here's a short academic-style note summarizing what was done:","title":"Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary-note-estimating-mass-of-earth-and-sun-using-keplers-third-law","text":"This document provides a manual derivation and computation of the mass of the Earth and the Sun using Kepler's Third Law : We used the formula: $$ M = \\frac{4\\pi^2 r^3}{G T^2} $$ which relates a satellite\u2019s orbital period ($T$) and radius ($r$) to the central body's mass ($M$). For the Earth , we used: Orbital altitude of 400 km, Period $T = 5400$ s, Earth radius $R = 6.371 \\times 10^6$ m, Result: \\(M_{Earth} \\approx 6.32 \\times 10^{24}\\ \\text{kg}\\) For the Sun , we used: Earth-Sun distance: $1.496 \\times 10^{11}$ m, Period $T = 1$ year, Result: \\(M_{Sun} \\approx 1.99 \\times 10^{30}\\ \\text{kg}\\)","title":"\ud83d\udcd8 Summary Note: Estimating Mass of Earth and Sun Using Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications","text":"Kepler's Third Law : \\(T^2 \\propto r^3\\) This relation: Helps determine the mass of the central object Predicts motion of satellites and moons Useful for astro-navigation and space missions","title":"Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-example-the-moon","text":"Mass of Earth: \\(M = 5.97 \\times 10^{24}\\) kg Radius of Moon's orbit: \\(r = 3.84 \\times 10^8\\) m Using: \\[T = 2\\pi \\sqrt{\\frac{r^3}{GM}}\\]","title":"Real-World Example: The Moon"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation","text":"","title":"Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_1","text":"import numpy as np import matplotlib.pyplot as plt import pandas as pd planets = { 'Mercury': {'r': 57.9e6, 'T': 0.241}, 'Venus': {'r': 108.2e6, 'T': 0.615}, 'Earth': {'r': 149.6e6, 'T': 1.000}, 'Mars': {'r': 227.9e6, 'T': 1.881} } data = { 'Planet': [], 'r (10^6 km)': [], 'T (years)': [], 'r\u00b3 (10^18 km\u00b3)': [], 'T\u00b2 (years\u00b2)': [] } for name, values in planets.items(): r = values['r'] T = values['T'] data['Planet'].append(name) data['r (10^6 km)'].append(r) data['T (years)'].append(T) data['r\u00b3 (10^18 km\u00b3)'].append((r**3) / 1e18) data['T\u00b2 (years\u00b2)'].append(T**2) df = pd.DataFrame(data) print(df) plt.plot(df['r\u00b3 (10^18 km\u00b3)'], df['T\u00b2 (years\u00b2)'], 'ro-', markersize=8) for i, txt in enumerate(df['Planet']): plt.annotate(txt, (df['r\u00b3 (10^18 km\u00b3)'][i], df['T\u00b2 (years\u00b2)'][i]), textcoords=\"offset points\", xytext=(5,5), ha='center') plt.xlabel(r'$r^3$ (in $10^{18}\\ km^3$)') plt.ylabel(r'$T^2$ (in $years^2$)') plt.title('Verification of Kepler\\'s Third Law with Solar System Planets') plt.grid(True) plt.show()","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#_2","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Orbital parameters (in astronomical units and years) radius = 1 # Orbital radius in AU period = 1 # Orbital period in years omega = 2 * np.pi / period # Angular velocity (rad/year) # Time array (convert years to days) t = np.linspace(0, period, 360) x = radius * np.cos(omega * t * 365) # X-position over time y = radius * np.sin(omega * t * 365) # Y-position over time # Set up the figure and axis fig, ax = plt.subplots(figsize=(6, 6)) ax.set_aspect('equal') ax.set_xlim(-1.5, 1.5) ax.set_ylim(-1.5, 1.5) ax.set_title(\"Circular Planet Orbit (Kepler's 3rd Law)\") ax.set_xlabel(\"X (AU)\") ax.set_ylabel(\"Y (AU)\") # Draw the Sun and initialize the planet sun = plt.Circle((0, 0), 0.05, color='gold', label='Sun') planet, = plt.plot([], [], 'o', color='blue', label='Planet') orbit, = plt.plot(x, y, linestyle='dotted', color='gray', alpha=0.5) # Add the Sun to the plot ax.add_artist(sun) ax.legend(loc=\"upper right\") # Animation update function def update(frame): # Modified to provide sequences to set_data planet.set_data([x[frame]], [y[frame]]) return planet, # Create animation ani = FuncAnimation(fig, update, frames=len(t), interval=30, blit=True) plt.show()","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Gravity Problem 2: Derivation of Three Cosmic Velocities 1. First Cosmic Velocity ( \\(v_1\\) ) The first cosmic velocity is the minimum velocity an object must have to remain in a stable orbit around a planet. The gravitational force provides the required centripetal force for circular motion. The gravitational force is: \\[ F_{\\text{gravity}} = \\frac{G M m}{R^2} \\] The centripetal force is: \\[ F_{\\text{centripetal}} = \\frac{m v_1^2}{R} \\] Setting these equal gives: \\[ \\frac{G M m}{R^2} = \\frac{m v_1^2}{R} \\] Simplifying: \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Thus, the first cosmic velocity is: \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] 2. Second Cosmic Velocity ( \\(v_2\\) ) The second cosmic velocity (escape velocity) is the minimum velocity needed to escape the gravitational pull of a planet. The kinetic energy must be equal to the gravitational potential energy to escape. The gravitational potential energy is: \\[ U = - \\frac{G M m}{R} \\] The kinetic energy needed to escape is: \\[ K = \\frac{1}{2} m v_2^2 \\] Setting the total energy to zero for escape: \\[ K + U = 0 \\] This gives: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Solving for \\(v_2\\) : \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} \\] Thus, the second cosmic velocity is: \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} \\] 3. Third Cosmic Velocity ( \\(v_3\\) ) The third cosmic velocity is the velocity required for an object to escape the Sun\u2019s gravitational influence, which is the escape velocity from the solar system at Earth's orbit. The equation for the third cosmic velocity is: \\[ v_3 = \\sqrt{\\frac{2 G M_{\\text{sun}}}{r_{\\text{sun}}}} \\] Where: - \\(M_{\\text{sun}}\\) is the mass of the Sun. - \\(r_{\\text{sun}}\\) is the distance from Earth to the Sun. Thus, the third cosmic velocity is: \\[ v_3 = \\sqrt{\\frac{2 G M_{\\text{sun}}}{r_{\\text{sun}}}} \\] Values of the Cosmic Velocities for Earth We will now calculate the values of the three cosmic velocities for Earth using the following constants: Gravitational constant, \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) Earth's mass, \\(M_{\\text{Earth}} = 5.97 \\times 10^{24} \\, \\text{kg}\\) Earth's radius, \\(R_{\\text{Earth}} = 6.371 \\times 10^{6} \\, \\text{m}\\) Sun's mass, \\(M_{\\text{sun}} = 1.989 \\times 10^{30} \\, \\text{kg}\\) Earth-Sun distance, \\(r_{\\text{sun}} = 1.496 \\times 10^{11} \\, \\text{m}\\) We can now compute the cosmic velocities for Earth. First Cosmic Velocity ( \\(v_1\\) ) : \\[ v_1 = \\sqrt{\\frac{G M_{\\text{Earth}}}{R_{\\text{Earth}}}} \\approx 7.91 \\, \\text{km/s} \\] Second Cosmic Velocity ( \\(v_2\\) ) : \\[ v_2 = \\sqrt{\\frac{2 G M_{\\text{Earth}}}{R_{\\text{Earth}}}} \\approx 11.2 \\, \\text{km/s} \\] Third Cosmic Velocity ( \\(v_3\\) ) : \\[ v_3 = \\sqrt{\\frac{2 G M_{\\text{sun}}}{r_{\\text{sun}}}} \\approx 42.1 \\, \\text{km/s} \\] Visual/Data Comparison with Moon, Mars, and Jupiter We now compare the cosmic velocities for Earth, Moon, Mars , and Jupiter . Below are the relevant properties of each body: Data for the planets and moons: Moon : Radius: \\(R_{\\text{Moon}} = 1.737 \\times 10^6 \\, \\text{m}\\) Mass: \\(M_{\\text{Moon}} = 7.35 \\times 10^{22} \\, \\text{kg}\\) Distance from Earth: \\(r_{\\text{Earth-Moon}} = 384,400 \\, \\text{km}\\) (we will consider Earth's escape velocity for comparison) Mars : Radius: \\(R_{\\text{Mars}} = 3.396 \\times 10^6 \\, \\text{m}\\) Mass: \\(M_{\\text{Mars}} = 6.42 \\times 10^{23} \\, \\text{kg}\\) Jupiter : Radius: \\(R_{\\text{Jupiter}} = 6.991 \\times 10^7 \\, \\text{m}\\) Mass: \\(M_{\\text{Jupiter}} = 1.90 \\times 10^{27} \\, \\text{kg}\\) These values can be used to compute the cosmic velocities for Moon , Mars , and Jupiter using the same formulas as above. Let me know if you need any more adjustments or if I can assist you further with anything else! \ud83d\udcca Visualization Ideas Bar Chart : Compare \\(v_1\\) and \\(v_2\\) for Earth, Moon, Mars, and Jupiter. Orbit Diagram : Visualize scale and escape paths. Energy Diagram : Show kinetic vs potential energy during escape. \ud83d\udcce Notes Third cosmic velocity ( \\(v_3\\) ) assumes an object escapes directly from Earth\u2019s orbit from the Sun \u2014 not from the Earth's surface. Actual mission trajectories involve complex gravity assists and slingshots. \ud83d\udcda Further Reading NASA Solar System Dynamics Fundamentals of Astrodynamics \u2013 Bate, Mueller, White import matplotlib.pyplot as plt # Data bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] v1 = [7.9, 1.68, 3.55, 42.1] v2 = [11.2, 2.38, 5.03, 59.5] v3 = [16.7, None, 14.1, 18.5] # Moon doesn't have v3 in same sense x = range(len(bodies)) # Plot plt.figure(figsize=(10, 6)) plt.bar(x, v1, width=0.25, label='First Cosmic Velocity (v1)', align='center') plt.bar([i + 0.25 for i in x], v2, width=0.25, label='Second Cosmic Velocity (v2)', align='center') plt.bar([i + 0.5 for i in x], [v if v else 0 for v in v3], width=0.25, label='Third Cosmic Velocity (v3)', align='center') plt.xticks([i + 0.25 for i in x], bodies) plt.ylabel('Velocity (km/s)') plt.title('Comparison of Cosmic Velocities') plt.legend() plt.grid(True, linestyle='--', alpha=0.7) plt.show() import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3 kg^-1 s^-2 M = 5.972e24 # mass of Earth in kg (we'll keep it constant for this graph) # Generate a range of planet radii (in meters) radii = np.linspace(1e6, 1.5e7, 500) # from 1000 km to 15000 km # Calculate first cosmic velocity for each radius v1 = np.sqrt(G * M / radii) # Convert velocity to km/s v1_km_s = v1 / 1000 # Plotting plt.figure(figsize=(10,6)) plt.plot(radii/1000, v1_km_s, label='First Cosmic Velocity', color='blue') # radii in km plt.xlabel('Planet Radius (km)') plt.ylabel('First Cosmic Velocity (km/s)') plt.title('First Cosmic Velocity vs Planet Radius') plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.show() import numpy as np import matplotlib.pyplot as plt # Gravitational constant (m^3 kg^-1 s^-2) G = 6.67430e-11 # Planetary data: Radius (m), Mass (kg) bodies = { \"Earth\": {\"R\": 6.371e6, \"M\": 5.97e24}, \"Moon\": {\"R\": 1.74e6, \"M\": 7.35e22}, \"Mars\": {\"R\": 3.39e6, \"M\": 6.42e23}, \"Jupiter\": {\"R\": 7.15e7, \"M\": 1.90e27} } # Calculate second cosmic velocity (v2) for each body radii = [] v2_values = [] labels = [] for body, data in bodies.items(): R = data[\"R\"] M = data[\"M\"] v2 = np.sqrt(2 * G * M / R) / 1000 # Convert to km/s radii.append(R / 1e6) # Convert radius to millions of kilometers v2_values.append(v2) labels.append(body) # Plotting: Second Cosmic Velocity vs Planet Radius (only second velocity) plt.figure(figsize=(10, 6)) # Create bar plot for escape velocity (v2) plt.bar(labels, v2_values, color='orange') # Adding title and labels plt.title(\"Second Cosmic Velocity (Escape Velocity) vs Planet Radius\") plt.xlabel(\"Celestial Body\") plt.ylabel(\"Escape Velocity (km/s)\") # Annotating bars with values for escape velocity for i, value in enumerate(v2_values): plt.text(i, value + 0.5, f\"{value:.1f} km/s\", ha='center', va='bottom') plt.grid(axis='y', linestyle='--', alpha=0.6) plt.tight_layout() plt.show() import matplotlib.pyplot as plt # Data for celestial bodies and their third cosmic velocities (km/s) bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] v3 = [16.7, None, 14.1, 18.5] # Third Cosmic Velocity (v3), None for Moon as it doesn't apply x = range(len(bodies)) # Plotting the bar chart for third cosmic velocity plt.figure(figsize=(10, 6)) # Third Cosmic Velocity (v3), None for Moon, replace None with 0 for the plot plt.bar(x, [v if v else 0 for v in v3], width=0.5, label='Third Cosmic Velocity (v3)', color='purple', align='center') # Set x-ticks to be the body names plt.xticks(x, bodies) # Adding labels and title plt.ylabel('Velocity (km/s)') plt.title('Third Cosmic Velocity for Planet Radius') # Adding a legend plt.legend() # Grid for better visualization plt.grid(True, linestyle='--', alpha=0.7) # Show the plot plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt # Define a range of first cosmic velocities (v1) in km/s v1 = np.linspace(0, 20, 500) # Calculate second cosmic velocities (v2) v2 = np.sqrt(2) * v1 # Plotting plt.figure(figsize=(10,6)) plt.plot(v1, v2, label=r'$v_2 = \\sqrt{2} \\times v_1$', color='green') plt.plot(v1, v1, linestyle='--', color='gray', label=r'$v_2 = v_1$ (reference line)') plt.xlabel('First Cosmic Velocity $v_1$ (km/s)') plt.ylabel('Second Cosmic Velocity $v_2$ (km/s)') plt.title('Relationship between First and Second Cosmic Velocities') plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.show()","title":"Gravity Problem 2: Derivation of Three Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravity-problem-2-derivation-of-three-cosmic-velocities","text":"","title":"Gravity Problem 2: Derivation of Three Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-v_1","text":"The first cosmic velocity is the minimum velocity an object must have to remain in a stable orbit around a planet. The gravitational force provides the required centripetal force for circular motion. The gravitational force is: \\[ F_{\\text{gravity}} = \\frac{G M m}{R^2} \\] The centripetal force is: \\[ F_{\\text{centripetal}} = \\frac{m v_1^2}{R} \\] Setting these equal gives: \\[ \\frac{G M m}{R^2} = \\frac{m v_1^2}{R} \\] Simplifying: \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Thus, the first cosmic velocity is: \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\]","title":"1. First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-v_2","text":"The second cosmic velocity (escape velocity) is the minimum velocity needed to escape the gravitational pull of a planet. The kinetic energy must be equal to the gravitational potential energy to escape. The gravitational potential energy is: \\[ U = - \\frac{G M m}{R} \\] The kinetic energy needed to escape is: \\[ K = \\frac{1}{2} m v_2^2 \\] Setting the total energy to zero for escape: \\[ K + U = 0 \\] This gives: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Solving for \\(v_2\\) : \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} \\] Thus, the second cosmic velocity is: \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} \\]","title":"2. Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-v_3","text":"The third cosmic velocity is the velocity required for an object to escape the Sun\u2019s gravitational influence, which is the escape velocity from the solar system at Earth's orbit. The equation for the third cosmic velocity is: \\[ v_3 = \\sqrt{\\frac{2 G M_{\\text{sun}}}{r_{\\text{sun}}}} \\] Where: - \\(M_{\\text{sun}}\\) is the mass of the Sun. - \\(r_{\\text{sun}}\\) is the distance from Earth to the Sun. Thus, the third cosmic velocity is: \\[ v_3 = \\sqrt{\\frac{2 G M_{\\text{sun}}}{r_{\\text{sun}}}} \\]","title":"3. Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#values-of-the-cosmic-velocities-for-earth","text":"We will now calculate the values of the three cosmic velocities for Earth using the following constants: Gravitational constant, \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) Earth's mass, \\(M_{\\text{Earth}} = 5.97 \\times 10^{24} \\, \\text{kg}\\) Earth's radius, \\(R_{\\text{Earth}} = 6.371 \\times 10^{6} \\, \\text{m}\\) Sun's mass, \\(M_{\\text{sun}} = 1.989 \\times 10^{30} \\, \\text{kg}\\) Earth-Sun distance, \\(r_{\\text{sun}} = 1.496 \\times 10^{11} \\, \\text{m}\\) We can now compute the cosmic velocities for Earth. First Cosmic Velocity ( \\(v_1\\) ) : \\[ v_1 = \\sqrt{\\frac{G M_{\\text{Earth}}}{R_{\\text{Earth}}}} \\approx 7.91 \\, \\text{km/s} \\] Second Cosmic Velocity ( \\(v_2\\) ) : \\[ v_2 = \\sqrt{\\frac{2 G M_{\\text{Earth}}}{R_{\\text{Earth}}}} \\approx 11.2 \\, \\text{km/s} \\] Third Cosmic Velocity ( \\(v_3\\) ) : \\[ v_3 = \\sqrt{\\frac{2 G M_{\\text{sun}}}{r_{\\text{sun}}}} \\approx 42.1 \\, \\text{km/s} \\]","title":"Values of the Cosmic Velocities for Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#visualdata-comparison-with-moon-mars-and-jupiter","text":"We now compare the cosmic velocities for Earth, Moon, Mars , and Jupiter . Below are the relevant properties of each body:","title":"Visual/Data Comparison with Moon, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#data-for-the-planets-and-moons","text":"Moon : Radius: \\(R_{\\text{Moon}} = 1.737 \\times 10^6 \\, \\text{m}\\) Mass: \\(M_{\\text{Moon}} = 7.35 \\times 10^{22} \\, \\text{kg}\\) Distance from Earth: \\(r_{\\text{Earth-Moon}} = 384,400 \\, \\text{km}\\) (we will consider Earth's escape velocity for comparison) Mars : Radius: \\(R_{\\text{Mars}} = 3.396 \\times 10^6 \\, \\text{m}\\) Mass: \\(M_{\\text{Mars}} = 6.42 \\times 10^{23} \\, \\text{kg}\\) Jupiter : Radius: \\(R_{\\text{Jupiter}} = 6.991 \\times 10^7 \\, \\text{m}\\) Mass: \\(M_{\\text{Jupiter}} = 1.90 \\times 10^{27} \\, \\text{kg}\\) These values can be used to compute the cosmic velocities for Moon , Mars , and Jupiter using the same formulas as above. Let me know if you need any more adjustments or if I can assist you further with anything else!","title":"Data for the planets and moons:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#visualization-ideas","text":"Bar Chart : Compare \\(v_1\\) and \\(v_2\\) for Earth, Moon, Mars, and Jupiter. Orbit Diagram : Visualize scale and escape paths. Energy Diagram : Show kinetic vs potential energy during escape.","title":"\ud83d\udcca Visualization Ideas"},{"location":"1%20Physics/2%20Gravity/Problem_2/#notes","text":"Third cosmic velocity ( \\(v_3\\) ) assumes an object escapes directly from Earth\u2019s orbit from the Sun \u2014 not from the Earth's surface. Actual mission trajectories involve complex gravity assists and slingshots.","title":"\ud83d\udcce Notes"},{"location":"1%20Physics/2%20Gravity/Problem_2/#further-reading","text":"NASA Solar System Dynamics Fundamentals of Astrodynamics \u2013 Bate, Mueller, White","title":"\ud83d\udcda Further Reading"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"import matplotlib.pyplot as plt # Data bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] v1 = [7.9, 1.68, 3.55, 42.1] v2 = [11.2, 2.38, 5.03, 59.5] v3 = [16.7, None, 14.1, 18.5] # Moon doesn't have v3 in same sense x = range(len(bodies)) # Plot plt.figure(figsize=(10, 6)) plt.bar(x, v1, width=0.25, label='First Cosmic Velocity (v1)', align='center') plt.bar([i + 0.25 for i in x], v2, width=0.25, label='Second Cosmic Velocity (v2)', align='center') plt.bar([i + 0.5 for i in x], [v if v else 0 for v in v3], width=0.25, label='Third Cosmic Velocity (v3)', align='center') plt.xticks([i + 0.25 for i in x], bodies) plt.ylabel('Velocity (km/s)') plt.title('Comparison of Cosmic Velocities') plt.legend() plt.grid(True, linestyle='--', alpha=0.7) plt.show()","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#_2","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3 kg^-1 s^-2 M = 5.972e24 # mass of Earth in kg (we'll keep it constant for this graph) # Generate a range of planet radii (in meters) radii = np.linspace(1e6, 1.5e7, 500) # from 1000 km to 15000 km # Calculate first cosmic velocity for each radius v1 = np.sqrt(G * M / radii) # Convert velocity to km/s v1_km_s = v1 / 1000 # Plotting plt.figure(figsize=(10,6)) plt.plot(radii/1000, v1_km_s, label='First Cosmic Velocity', color='blue') # radii in km plt.xlabel('Planet Radius (km)') plt.ylabel('First Cosmic Velocity (km/s)') plt.title('First Cosmic Velocity vs Planet Radius') plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.show()","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#_3","text":"import numpy as np import matplotlib.pyplot as plt # Gravitational constant (m^3 kg^-1 s^-2) G = 6.67430e-11 # Planetary data: Radius (m), Mass (kg) bodies = { \"Earth\": {\"R\": 6.371e6, \"M\": 5.97e24}, \"Moon\": {\"R\": 1.74e6, \"M\": 7.35e22}, \"Mars\": {\"R\": 3.39e6, \"M\": 6.42e23}, \"Jupiter\": {\"R\": 7.15e7, \"M\": 1.90e27} } # Calculate second cosmic velocity (v2) for each body radii = [] v2_values = [] labels = [] for body, data in bodies.items(): R = data[\"R\"] M = data[\"M\"] v2 = np.sqrt(2 * G * M / R) / 1000 # Convert to km/s radii.append(R / 1e6) # Convert radius to millions of kilometers v2_values.append(v2) labels.append(body) # Plotting: Second Cosmic Velocity vs Planet Radius (only second velocity) plt.figure(figsize=(10, 6)) # Create bar plot for escape velocity (v2) plt.bar(labels, v2_values, color='orange') # Adding title and labels plt.title(\"Second Cosmic Velocity (Escape Velocity) vs Planet Radius\") plt.xlabel(\"Celestial Body\") plt.ylabel(\"Escape Velocity (km/s)\") # Annotating bars with values for escape velocity for i, value in enumerate(v2_values): plt.text(i, value + 0.5, f\"{value:.1f} km/s\", ha='center', va='bottom') plt.grid(axis='y', linestyle='--', alpha=0.6) plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#_4","text":"import matplotlib.pyplot as plt # Data for celestial bodies and their third cosmic velocities (km/s) bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] v3 = [16.7, None, 14.1, 18.5] # Third Cosmic Velocity (v3), None for Moon as it doesn't apply x = range(len(bodies)) # Plotting the bar chart for third cosmic velocity plt.figure(figsize=(10, 6)) # Third Cosmic Velocity (v3), None for Moon, replace None with 0 for the plot plt.bar(x, [v if v else 0 for v in v3], width=0.5, label='Third Cosmic Velocity (v3)', color='purple', align='center') # Set x-ticks to be the body names plt.xticks(x, bodies) # Adding labels and title plt.ylabel('Velocity (km/s)') plt.title('Third Cosmic Velocity for Planet Radius') # Adding a legend plt.legend() # Grid for better visualization plt.grid(True, linestyle='--', alpha=0.7) # Show the plot plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#_5","text":"import numpy as np import matplotlib.pyplot as plt # Define a range of first cosmic velocities (v1) in km/s v1 = np.linspace(0, 20, 500) # Calculate second cosmic velocities (v2) v2 = np.sqrt(2) * v1 # Plotting plt.figure(figsize=(10,6)) plt.plot(v1, v2, label=r'$v_2 = \\sqrt{2} \\times v_1$', color='green') plt.plot(v1, v1, linestyle='--', color='gray', label=r'$v_2 = v_1$ (reference line)') plt.xlabel('First Cosmic Velocity $v_1$ (km/s)') plt.ylabel('Second Cosmic Velocity $v_2$ (km/s)') plt.title('Relationship between First and Second Cosmic Velocities') plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.show()","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3: Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario blends principles of orbital mechanics and numerical methods. Understanding the possible trajectories (parabolic, hyperbolic, elliptical) of such a payload is vital for space missions, such as deploying payloads or returning objects to Earth. Task Overview Analyze the possible trajectories of a payload released near Earth (parabolic, hyperbolic, elliptical). Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions. Gravitational Forces and Trajectory Analysis Fundamental Equations Gravitational Force: The force between two masses is given by Newton's Law of Gravitation: $$ F = \\frac{G M m}{r^2} $$ Where: - \\(F\\) is the gravitational force. - \\(G\\) is the gravitational constant. - \\(M\\) is the mass of the Earth. - \\(m\\) is the mass of the payload. - \\(r\\) is the distance between the payload and the center of the Earth. Potential Energy: The gravitational potential energy is: $$ U = - \\frac{G M m}{r} $$ Kinetic Energy: The kinetic energy is: $$ K = \\frac{1}{2} m v^2 $$ Total Energy: The total energy of the system is the sum of kinetic and potential energies: $$ E_{\\text{total}} = K + U = \\frac{1}{2} m v^2 - \\frac{G M m}{r} $$ Depending on the value of \\(E_{\\text{total}}\\) , the trajectory of the payload can be: - Elliptical: If \\(E_{\\text{total}} < 0\\) . - Parabolic: If \\(E_{\\text{total}} = 0\\) . - Hyperbolic: If \\(E_{\\text{total}} > 0\\) . Numerical Methods for Simulation To simulate the trajectory, we need to solve the following set of equations using numerical methods like Euler's method or Runge-Kutta method: Position and Velocity Equations: Newton's second law: \\(F = ma\\) . For a moving object in two dimensions, we can write: \\(\\ddot{x} = - \\frac{G M x}{(x^2 + y^2)^{3/2}}\\) \\(\\ddot{y} = - \\frac{G M y}{(x^2 + y^2)^{3/2}}\\) Where: - \\((x, y)\\) are the position coordinates of the payload. - \\(\\ddot{x}\\) and \\(\\ddot{y}\\) are the accelerations in the \\(x\\) and \\(y\\) directions. Initial Conditions: Initial position \\((x_0, y_0)\\) . Initial velocity \\((v_{x0}, v_{y0})\\) . Simulating the Trajectories: We'll implement the simulation using Python and visualize the resulting trajectories. Python Code for Trajectory Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.97e24 # Mass of Earth (kg) radius_earth = 6.371e6 # Radius of Earth (m) # Time parameters dt = 100 # Time step (seconds) T = 3600 * 24 # Total time of simulation (1 day) # Initial conditions: (initial position, initial velocity) initial_conditions = { 'x0': 1.5 * radius_earth, # 1.5 Earth radii from Earth's center (m) 'y0': 0, # Along the x-axis (horizontal direction) 'vx0': 0, # Initial velocity in x-direction (m/s) 'vy0': 5000 # Initial velocity in y-direction (m/s) } # Function to compute acceleration due to gravity def gravity_acceleration(x, y): r = np.sqrt(x**2 + y**2) # Distance from Earth's center a = -G * M / r**2 # Gravitational acceleration ax = a * x / r # Acceleration in x-direction ay = a * y / r # Acceleration in y-direction return ax, ay # Initialize position and velocity arrays x, y = [initial_conditions['x0']], [initial_conditions['y0']] vx, vy = [initial_conditions['vx0']], [initial_conditions['vy0']] # Numerical integration using Euler's method for t in np.arange(0, T, dt): ax, ay = gravity_acceleration(x[-1], y[-1]) # Get acceleration at current position # Update velocities vx.append(vx[-1] + ax * dt) vy.append(vy[-1] + ay * dt) # Update positions x.append(x[-1] + vx[-1] * dt) y.append(y[-1] + vy[-1] * dt) # Convert the results into numpy arrays for easier plotting x = np.array(x) y = np.array(y) # Plot the trajectory plt.figure(figsize=(8, 6)) plt.plot(x / 1e3, y / 1e3) # Convert to km for visualization plt.scatter([0], [0], color='orange', label='Earth') # Plot Earth at origin plt.title('Payload Trajectory Near Earth') plt.xlabel('X Position (km)') plt.ylabel('Y Position (km)') plt.grid(True) plt.legend() plt.axis('equal') plt.show() import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth R = 6.371e6 # radius of Earth in meters altitude = 800e3 # 800 km above the surface initial_distance = R + altitude time_step = 1 # seconds total_time = 7000 # simulate up to 7000 seconds n_steps = int(total_time / time_step) # Initial velocities in m/s velocities = np.arange(5000, 13500, 500) # from 5 km/s to 13 km/s # Create Earth plot plt.figure(figsize=(10, 10)) theta = np.linspace(0, 2*np.pi, 300) earth_x = R * np.cos(theta) earth_y = R * np.sin(theta) plt.fill(earth_x, earth_y, 'blue', alpha=0.5, label='Earth') # Function to compute gravity acceleration def gravity(pos): r = np.linalg.norm(pos) return -G * M * pos / r**3 # Simulate each trajectory for v in velocities: pos = np.array([initial_distance, 0.0]) vel = np.array([0.0, v]) traj = [] for _ in range(n_steps): acc = gravity(pos) vel += acc * time_step pos += vel * time_step traj.append(pos.copy()) if np.linalg.norm(pos) <= R: break traj = np.array(traj) plt.plot(traj[:, 0], traj[:, 1], label=f'{v/1000:.1f} km/s') # Plot settings plt.plot(0, 0, 'ko', label='Center of Earth') plt.axis('equal') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Trajectories of Objects from 800 km Altitude with Varying Speeds') plt.legend() plt.grid(True) plt.show()","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario blends principles of orbital mechanics and numerical methods. Understanding the possible trajectories (parabolic, hyperbolic, elliptical) of such a payload is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task-overview","text":"Analyze the possible trajectories of a payload released near Earth (parabolic, hyperbolic, elliptical). Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions.","title":"Task Overview"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravitational-forces-and-trajectory-analysis","text":"","title":"Gravitational Forces and Trajectory Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#fundamental-equations","text":"Gravitational Force: The force between two masses is given by Newton's Law of Gravitation: $$ F = \\frac{G M m}{r^2} $$ Where: - \\(F\\) is the gravitational force. - \\(G\\) is the gravitational constant. - \\(M\\) is the mass of the Earth. - \\(m\\) is the mass of the payload. - \\(r\\) is the distance between the payload and the center of the Earth. Potential Energy: The gravitational potential energy is: $$ U = - \\frac{G M m}{r} $$ Kinetic Energy: The kinetic energy is: $$ K = \\frac{1}{2} m v^2 $$ Total Energy: The total energy of the system is the sum of kinetic and potential energies: $$ E_{\\text{total}} = K + U = \\frac{1}{2} m v^2 - \\frac{G M m}{r} $$ Depending on the value of \\(E_{\\text{total}}\\) , the trajectory of the payload can be: - Elliptical: If \\(E_{\\text{total}} < 0\\) . - Parabolic: If \\(E_{\\text{total}} = 0\\) . - Hyperbolic: If \\(E_{\\text{total}} > 0\\) .","title":"Fundamental Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-methods-for-simulation","text":"To simulate the trajectory, we need to solve the following set of equations using numerical methods like Euler's method or Runge-Kutta method: Position and Velocity Equations: Newton's second law: \\(F = ma\\) . For a moving object in two dimensions, we can write: \\(\\ddot{x} = - \\frac{G M x}{(x^2 + y^2)^{3/2}}\\) \\(\\ddot{y} = - \\frac{G M y}{(x^2 + y^2)^{3/2}}\\) Where: - \\((x, y)\\) are the position coordinates of the payload. - \\(\\ddot{x}\\) and \\(\\ddot{y}\\) are the accelerations in the \\(x\\) and \\(y\\) directions. Initial Conditions: Initial position \\((x_0, y_0)\\) . Initial velocity \\((v_{x0}, v_{y0})\\) .","title":"Numerical Methods for Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulating-the-trajectories","text":"We'll implement the simulation using Python and visualize the resulting trajectories.","title":"Simulating the Trajectories:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-for-trajectory-simulation","text":"","title":"Python Code for Trajectory Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_1","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.97e24 # Mass of Earth (kg) radius_earth = 6.371e6 # Radius of Earth (m) # Time parameters dt = 100 # Time step (seconds) T = 3600 * 24 # Total time of simulation (1 day) # Initial conditions: (initial position, initial velocity) initial_conditions = { 'x0': 1.5 * radius_earth, # 1.5 Earth radii from Earth's center (m) 'y0': 0, # Along the x-axis (horizontal direction) 'vx0': 0, # Initial velocity in x-direction (m/s) 'vy0': 5000 # Initial velocity in y-direction (m/s) } # Function to compute acceleration due to gravity def gravity_acceleration(x, y): r = np.sqrt(x**2 + y**2) # Distance from Earth's center a = -G * M / r**2 # Gravitational acceleration ax = a * x / r # Acceleration in x-direction ay = a * y / r # Acceleration in y-direction return ax, ay # Initialize position and velocity arrays x, y = [initial_conditions['x0']], [initial_conditions['y0']] vx, vy = [initial_conditions['vx0']], [initial_conditions['vy0']] # Numerical integration using Euler's method for t in np.arange(0, T, dt): ax, ay = gravity_acceleration(x[-1], y[-1]) # Get acceleration at current position # Update velocities vx.append(vx[-1] + ax * dt) vy.append(vy[-1] + ay * dt) # Update positions x.append(x[-1] + vx[-1] * dt) y.append(y[-1] + vy[-1] * dt) # Convert the results into numpy arrays for easier plotting x = np.array(x) y = np.array(y) # Plot the trajectory plt.figure(figsize=(8, 6)) plt.plot(x / 1e3, y / 1e3) # Convert to km for visualization plt.scatter([0], [0], color='orange', label='Earth') # Plot Earth at origin plt.title('Payload Trajectory Near Earth') plt.xlabel('X Position (km)') plt.ylabel('Y Position (km)') plt.grid(True) plt.legend() plt.axis('equal') plt.show()","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#_2","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth R = 6.371e6 # radius of Earth in meters altitude = 800e3 # 800 km above the surface initial_distance = R + altitude time_step = 1 # seconds total_time = 7000 # simulate up to 7000 seconds n_steps = int(total_time / time_step) # Initial velocities in m/s velocities = np.arange(5000, 13500, 500) # from 5 km/s to 13 km/s # Create Earth plot plt.figure(figsize=(10, 10)) theta = np.linspace(0, 2*np.pi, 300) earth_x = R * np.cos(theta) earth_y = R * np.sin(theta) plt.fill(earth_x, earth_y, 'blue', alpha=0.5, label='Earth') # Function to compute gravity acceleration def gravity(pos): r = np.linalg.norm(pos) return -G * M * pos / r**3 # Simulate each trajectory for v in velocities: pos = np.array([initial_distance, 0.0]) vel = np.array([0.0, v]) traj = [] for _ in range(n_steps): acc = gravity(pos) vel += acc * time_step pos += vel * time_step traj.append(pos.copy()) if np.linalg.norm(pos) <= R: break traj = np.array(traj) plt.plot(traj[:, 0], traj[:, 1], label=f'{v/1000:.1f} km/s') # Plot settings plt.plot(0, 0, 'ko', label='Center of Earth') plt.axis('equal') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Trajectories of Objects from 800 km Altitude with Varying Speeds') plt.legend() plt.grid(True) plt.show()","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"\ud83c\udf0a Interference Patterns of Circular Water Waves from Point Sources \ud83d\udd39 Task Description A circular wave on the water surface, emanating from a point source located at \\((x_0, y_0)\\) , is described by the Single Disturbance Equation : \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) : Displacement of the water surface at point \\((x, y)\\) and time \\(t\\) \\(A\\) : Amplitude of the wave \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number, with \\(\\lambda\\) as the wavelength \\(\\omega = 2\\pi f\\) : Angular frequency, with \\(f\\) as the wave frequency \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from source to the point \\((x, y)\\) \\(\\phi\\) : Initial phase of the wave \u2753 Problem Statement Your task is to analyze the interference patterns on the water surface caused by the superposition of waves emitted from point sources placed at the vertices of a regular polygon . \u2705 Steps to Follow 1. Select a Regular Polygon Choose a regular polygon: - Equilateral Triangle (3 vertices) - Square (4 vertices) - Regular Pentagon (5 vertices) - etc. 2. Position the Sources Place wave sources at the vertices of the polygon. For a polygon centered at the origin: - Let the radius be \\(R\\) - The \\(i^{th}\\) vertex is at: $$ (x_i, y_i) = \\left(R\\cos\\left(\\frac{2\\pi i}{N}\\right), R\\sin\\left(\\frac{2\\pi i}{N}\\right)\\right) $$ 3. Write the Wave Equations Each source emits a wave described by: \\[ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cdot \\cos(k r_i - \\omega t + \\phi) \\] Where: - \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) 4. Superposition of Waves The total displacement at a point \\((x, y)\\) and time \\(t\\) is given by: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Where: - \\(N\\) is the number of sources (polygon vertices) \ud83d\udd2c Analyze Interference Patterns Compute \\(\\eta_{\\text{sum}}(x, y, t)\\) over a grid of \\((x, y)\\) points for a fixed time \\(t\\) Identify: Constructive interference : Wave amplitudes add up (bright/fringe regions) Destructive interference : Wave amplitudes cancel (dark/null regions) \ud83d\udcca Visualization Use 2D heatmaps or 3D surface plots Plot \\(\\eta_{\\text{sum}}(x, y, t)\\) over a defined region Observe symmetrical patterns based on the chosen polygon \ud83e\udde0 Optional Enhancements Animate \\(\\eta_{\\text{sum}}(x, y, t)\\) over time Explore effects of: Changing phase \\(\\phi\\) Different frequencies \\(\\omega\\) Different polygon types import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib import animation from IPython.display import Image from google.colab import files # Parameters A = 1.0 # Amplitude k = 2 * np.pi / 1.0 # Wave number omega = 1.0 # Angular frequency phi = 0.0 # Initial phase # Define triangle's vertices sources = np.array([ [0, np.sqrt(3)], # Top vertex [-1, 0], # Bottom-left [1, 0] # Bottom-right ]) # Create a smaller grid x = np.linspace(-2, 2, 50) y = np.linspace(-2, 2, 50) X, Y = np.meshgrid(x, y) # Wave equation for a single source def wave(X, Y, x0, y0, t): r = np.sqrt((X - x0)**2 + (Y - y0)**2) r = np.maximum(r, 1e-10) # Avoid division by zero return (A / np.sqrt(r)) * np.cos(k * r - omega * t + phi) # Compute total wave def get_total_wave(t): eta_total = np.zeros_like(X) for x0, y0 in sources: eta_total += wave(X, Y, x0, y0, t) return eta_total # 2D Plot and Animation fig2d, ax2d = plt.subplots(figsize=(8, 6)) contour = ax2d.contourf(X, Y, get_total_wave(0), levels=50, cmap='seismic') plt.colorbar(contour, ax=ax2d, label='Wave Displacement') ax2d.scatter(sources[:, 0], sources[:, 1], c='black', marker='o', label='Sources') ax2d.set_title('Interference Pattern (2D)') ax2d.set_xlabel('x') ax2d.set_ylabel('y') ax2d.legend() ax2d.grid(True) def update_2d(frame): t = frame * 0.05 ax2d.clear() eta_total = get_total_wave(t) contour = ax2d.contourf(X, Y, eta_total, levels=50, cmap='seismic') ax2d.scatter(sources[:, 0], sources[:, 1], c='black', marker='o', label='Sources') ax2d.set_title(f'Interference Pattern (2D, t={t:.2f})') ax2d.set_xlabel('x') ax2d.set_ylabel('y') ax2d.legend() ax2d.grid(True) return [contour] # Return the QuadContourSet object as a list ani2d = animation.FuncAnimation(fig2d, update_2d, frames=50, interval=50, blit=False) writer2d = animation.PillowWriter(fps=10) # Use PillowWriter for GIF ani2d.save('triangle_interference_2d.gif', writer=writer2d) plt.close(fig2d) # 3D Plot and Animation fig3d = plt.figure(figsize=(8, 6)) ax3d = fig3d.add_subplot(111, projection='3d') eta_total = get_total_wave(0) surf = ax3d.plot_surface(X, Y, eta_total, cmap='seismic') fig3d.colorbar(surf, ax=ax3d, label='Wave Displacement') ax3d.set_title('Interference Pattern (3D)') ax3d.set_xlabel('x') ax3d.set_ylabel('y') ax3d.set_zlabel('Wave Displacement') def update_3d(frame): t = frame * 0.05 ax3d.clear() eta_total = get_total_wave(t) surf = ax3d.plot_surface(X, Y, eta_total, cmap='seismic') ax3d.set_title(f'Interference Pattern (3D, t={t:.2f})') ax3d.set_xlabel('x') ax3d.set_ylabel('y') ax3d.set_zlabel('Wave Displacement') return [surf] ani3d = animation.FuncAnimation(fig3d, update_3d, frames=50, interval=50, blit=False) writer3d = animation.PillowWriter(fps=10) # Use PillowWriter for GIF ani3d.save('triangle_interference_3d.gif', writer=writer3d) plt.close(fig3d) # Display GIFs inline print(\"2D Animation:\") display(Image(filename='triangle_interference_2d.gif')) print(\"3D Animation:\") display(Image(filename='triangle_interference_3d.gif')) # Optionally download GIFs files.download('triangle_interference_2d.gif') files.download('triangle_interference_3d.gif') import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Define the grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Define wave parameters wavelength = 2 # Wavelength k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi / 5 # Angular frequency t = 0 # Static time for snapshot (can be animated) # Function to create a wave from a single source def single_wave(X, Y, source): r = np.sqrt((X - source[0])**2 + (Y - source[1])**2) return np.sin(k * r - omega * t) # Function to sum multiple waves from different sources def multiple_waves(X, Y, sources): Z = np.zeros_like(X) for source in sources: Z += single_wave(X, Y, source) return Z # ------------------------ # Sources definitions # ------------------------ sources_1 = [(0, 0)] distance = 5 sources_4 = [(-distance, -distance), (-distance, distance), (distance, -distance), (distance, distance)] radius = 5 angles = np.linspace(0, 2 * np.pi, 6)[:-1] sources_5 = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # ------------------------ # Plotting Function # ------------------------ def plot_wave(Z, title): fig, axs = plt.subplots(1, 2, figsize=(18, 8)) # BIGGER SIZE # Heatmap im = axs[0].imshow(Z, extent=[-10, 10, -10, 10], origin='lower', cmap='viridis') axs[0].set_title(f\"{title} - Heatmap\", fontsize=18) axs[0].set_xlabel('X axis', fontsize=14) axs[0].set_ylabel('Y axis', fontsize=14) plt.colorbar(im, ax=axs[0]) # 3D Surface ax = fig.add_subplot(1, 2, 2, projection='3d') ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title(f\"{title} - 3D Surface\", fontsize=18) ax.set_xlabel('X axis', fontsize=14) ax.set_ylabel('Y axis', fontsize=14) ax.set_zlabel('Amplitude', fontsize=14) plt.tight_layout() plt.show() # ------------------------ # Calculate and plot all # ------------------------ Z1 = multiple_waves(X, Y, sources_1) Z4 = multiple_waves(X, Y, sources_4) Z5 = multiple_waves(X, Y, sources_5) plot_wave(Z1, \"Single Source\") plot_wave(Z4, \"Four Sources (Square)\") plot_wave(Z5, \"Five Sources (Pentagon)\")","title":"\ud83c\udf0a Interference Patterns of Circular Water Waves from Point Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-of-circular-water-waves-from-point-sources","text":"","title":"\ud83c\udf0a Interference Patterns of Circular Water Waves from Point Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#task-description","text":"A circular wave on the water surface, emanating from a point source located at \\((x_0, y_0)\\) , is described by the Single Disturbance Equation : \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\]","title":"\ud83d\udd39 Task Description"},{"location":"1%20Physics/3%20Waves/Problem_1/#where","text":"\\(\\eta(x, y, t)\\) : Displacement of the water surface at point \\((x, y)\\) and time \\(t\\) \\(A\\) : Amplitude of the wave \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number, with \\(\\lambda\\) as the wavelength \\(\\omega = 2\\pi f\\) : Angular frequency, with \\(f\\) as the wave frequency \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from source to the point \\((x, y)\\) \\(\\phi\\) : Initial phase of the wave","title":"Where:"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"Your task is to analyze the interference patterns on the water surface caused by the superposition of waves emitted from point sources placed at the vertices of a regular polygon .","title":"\u2753 Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps-to-follow","text":"","title":"\u2705 Steps to Follow"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-select-a-regular-polygon","text":"Choose a regular polygon: - Equilateral Triangle (3 vertices) - Square (4 vertices) - Regular Pentagon (5 vertices) - etc.","title":"1. Select a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-position-the-sources","text":"Place wave sources at the vertices of the polygon. For a polygon centered at the origin: - Let the radius be \\(R\\) - The \\(i^{th}\\) vertex is at: $$ (x_i, y_i) = \\left(R\\cos\\left(\\frac{2\\pi i}{N}\\right), R\\sin\\left(\\frac{2\\pi i}{N}\\right)\\right) $$","title":"2. Position the Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-write-the-wave-equations","text":"Each source emits a wave described by: \\[ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cdot \\cos(k r_i - \\omega t + \\phi) \\] Where: - \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\)","title":"3. Write the Wave Equations"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-superposition-of-waves","text":"The total displacement at a point \\((x, y)\\) and time \\(t\\) is given by: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Where: - \\(N\\) is the number of sources (polygon vertices)","title":"4. Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#analyze-interference-patterns","text":"Compute \\(\\eta_{\\text{sum}}(x, y, t)\\) over a grid of \\((x, y)\\) points for a fixed time \\(t\\) Identify: Constructive interference : Wave amplitudes add up (bright/fringe regions) Destructive interference : Wave amplitudes cancel (dark/null regions)","title":"\ud83d\udd2c Analyze Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#visualization","text":"Use 2D heatmaps or 3D surface plots Plot \\(\\eta_{\\text{sum}}(x, y, t)\\) over a defined region Observe symmetrical patterns based on the chosen polygon","title":"\ud83d\udcca Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#optional-enhancements","text":"Animate \\(\\eta_{\\text{sum}}(x, y, t)\\) over time Explore effects of: Changing phase \\(\\phi\\) Different frequencies \\(\\omega\\) Different polygon types import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib import animation from IPython.display import Image from google.colab import files # Parameters A = 1.0 # Amplitude k = 2 * np.pi / 1.0 # Wave number omega = 1.0 # Angular frequency phi = 0.0 # Initial phase # Define triangle's vertices sources = np.array([ [0, np.sqrt(3)], # Top vertex [-1, 0], # Bottom-left [1, 0] # Bottom-right ]) # Create a smaller grid x = np.linspace(-2, 2, 50) y = np.linspace(-2, 2, 50) X, Y = np.meshgrid(x, y) # Wave equation for a single source def wave(X, Y, x0, y0, t): r = np.sqrt((X - x0)**2 + (Y - y0)**2) r = np.maximum(r, 1e-10) # Avoid division by zero return (A / np.sqrt(r)) * np.cos(k * r - omega * t + phi) # Compute total wave def get_total_wave(t): eta_total = np.zeros_like(X) for x0, y0 in sources: eta_total += wave(X, Y, x0, y0, t) return eta_total # 2D Plot and Animation fig2d, ax2d = plt.subplots(figsize=(8, 6)) contour = ax2d.contourf(X, Y, get_total_wave(0), levels=50, cmap='seismic') plt.colorbar(contour, ax=ax2d, label='Wave Displacement') ax2d.scatter(sources[:, 0], sources[:, 1], c='black', marker='o', label='Sources') ax2d.set_title('Interference Pattern (2D)') ax2d.set_xlabel('x') ax2d.set_ylabel('y') ax2d.legend() ax2d.grid(True) def update_2d(frame): t = frame * 0.05 ax2d.clear() eta_total = get_total_wave(t) contour = ax2d.contourf(X, Y, eta_total, levels=50, cmap='seismic') ax2d.scatter(sources[:, 0], sources[:, 1], c='black', marker='o', label='Sources') ax2d.set_title(f'Interference Pattern (2D, t={t:.2f})') ax2d.set_xlabel('x') ax2d.set_ylabel('y') ax2d.legend() ax2d.grid(True) return [contour] # Return the QuadContourSet object as a list ani2d = animation.FuncAnimation(fig2d, update_2d, frames=50, interval=50, blit=False) writer2d = animation.PillowWriter(fps=10) # Use PillowWriter for GIF ani2d.save('triangle_interference_2d.gif', writer=writer2d) plt.close(fig2d) # 3D Plot and Animation fig3d = plt.figure(figsize=(8, 6)) ax3d = fig3d.add_subplot(111, projection='3d') eta_total = get_total_wave(0) surf = ax3d.plot_surface(X, Y, eta_total, cmap='seismic') fig3d.colorbar(surf, ax=ax3d, label='Wave Displacement') ax3d.set_title('Interference Pattern (3D)') ax3d.set_xlabel('x') ax3d.set_ylabel('y') ax3d.set_zlabel('Wave Displacement') def update_3d(frame): t = frame * 0.05 ax3d.clear() eta_total = get_total_wave(t) surf = ax3d.plot_surface(X, Y, eta_total, cmap='seismic') ax3d.set_title(f'Interference Pattern (3D, t={t:.2f})') ax3d.set_xlabel('x') ax3d.set_ylabel('y') ax3d.set_zlabel('Wave Displacement') return [surf] ani3d = animation.FuncAnimation(fig3d, update_3d, frames=50, interval=50, blit=False) writer3d = animation.PillowWriter(fps=10) # Use PillowWriter for GIF ani3d.save('triangle_interference_3d.gif', writer=writer3d) plt.close(fig3d) # Display GIFs inline print(\"2D Animation:\") display(Image(filename='triangle_interference_2d.gif')) print(\"3D Animation:\") display(Image(filename='triangle_interference_3d.gif')) # Optionally download GIFs files.download('triangle_interference_2d.gif') files.download('triangle_interference_3d.gif') import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Define the grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Define wave parameters wavelength = 2 # Wavelength k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi / 5 # Angular frequency t = 0 # Static time for snapshot (can be animated) # Function to create a wave from a single source def single_wave(X, Y, source): r = np.sqrt((X - source[0])**2 + (Y - source[1])**2) return np.sin(k * r - omega * t) # Function to sum multiple waves from different sources def multiple_waves(X, Y, sources): Z = np.zeros_like(X) for source in sources: Z += single_wave(X, Y, source) return Z # ------------------------ # Sources definitions # ------------------------ sources_1 = [(0, 0)] distance = 5 sources_4 = [(-distance, -distance), (-distance, distance), (distance, -distance), (distance, distance)] radius = 5 angles = np.linspace(0, 2 * np.pi, 6)[:-1] sources_5 = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # ------------------------ # Plotting Function # ------------------------ def plot_wave(Z, title): fig, axs = plt.subplots(1, 2, figsize=(18, 8)) # BIGGER SIZE # Heatmap im = axs[0].imshow(Z, extent=[-10, 10, -10, 10], origin='lower', cmap='viridis') axs[0].set_title(f\"{title} - Heatmap\", fontsize=18) axs[0].set_xlabel('X axis', fontsize=14) axs[0].set_ylabel('Y axis', fontsize=14) plt.colorbar(im, ax=axs[0]) # 3D Surface ax = fig.add_subplot(1, 2, 2, projection='3d') ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title(f\"{title} - 3D Surface\", fontsize=18) ax.set_xlabel('X axis', fontsize=14) ax.set_ylabel('Y axis', fontsize=14) ax.set_zlabel('Amplitude', fontsize=14) plt.tight_layout() plt.show() # ------------------------ # Calculate and plot all # ------------------------ Z1 = multiple_waves(X, Y, sources_1) Z4 = multiple_waves(X, Y, sources_4) Z5 = multiple_waves(X, Y, sources_5) plot_wave(Z1, \"Single Source\") plot_wave(Z4, \"Four Sources (Square)\") plot_wave(Z5, \"Five Sources (Pentagon)\")","title":"\ud83e\udde0 Optional Enhancements"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Electromagnetism Problem 1: Simulating the Effects of the Lorentz Force Introduction: The Lorentz force is the force experienced by a charged particle due to electromagnetic fields. It is a fundamental concept in electromagnetism and governs the behavior of particles in many physical systems. The force is given by the following equation: \\[ \\mathbf{F} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] Where: - \\(\\mathbf{F}\\) is the force on the particle, - \\(q\\) is the charge of the particle, - \\(\\mathbf{E}\\) is the electric field, - \\(\\mathbf{v}\\) is the velocity of the particle, - \\(\\mathbf{B}\\) is the magnetic field. The Lorentz force is responsible for the motion of charged particles in systems such as particle accelerators , mass spectrometers , plasma confinement devices , and magnetic traps . This task focuses on simulating the effects of this force on the motion of a particle under different electromagnetic field configurations. Physical Parameters: To simplify the simulation and avoid subatomic-scale complexities, we define the following parameters for the charged particle: Charge \\(q = 1 \\, \\text{C}\\) : The charge of the particle is set to 1 Coulomb. Mass \\(m = 1 \\, \\text{g} = 1 \\times 10^{-3} \\, \\text{kg}\\) : The particle\u2019s mass is set to 1 gram. Magnetic Field \\(\\mathbf{B} = [0, 0, 1] \\, \\text{T}\\) : A uniform magnetic field along the \\(z\\) -axis (1 Tesla). Electric Field \\(\\mathbf{E} = [0, 0, 0] \\, \\text{V/m}\\) : Initially, no electric field is applied. Initial Velocity \\(\\mathbf{v_0} = [1, 0, 0] \\, \\text{m/s}\\) : The particle starts with an initial velocity of 1 m/s along the \\(x\\) -axis. Initial Position \\(\\mathbf{r_0} = [0, 0, 0] \\, \\text{m}\\) : The particle starts at the origin. These parameters define the initial conditions for the simulation and are key to understanding how different configurations of electric and magnetic fields affect particle motion. Equations of Motion: The Lorentz force law governs the motion of the particle. The equations of motion for a charged particle in electromagnetic fields are: \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] \\[ \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m} \\left( \\mathbf{E} + \\mathbf{v} \\times \\mathbf{B} \\right) \\] Where: - \\(\\mathbf{r}\\) is the particle\u2019s position, - \\(\\mathbf{v}\\) is the particle\u2019s velocity, - \\(\\mathbf{E}\\) is the electric field, - \\(\\mathbf{B}\\) is the magnetic field, - \\(\\mathbf{F}\\) is the Lorentz force. The first equation describes how the position of the particle changes over time, and the second equation governs the velocity change due to the Lorentz force. These differential equations are solved numerically to simulate the particle's trajectory over time. Scenarios and Trajectories: 1. Uniform Magnetic Field (Circular Motion): When only a magnetic field is present, the charged particle moves in a circular trajectory perpendicular to the magnetic field. The Larmor radius describes the radius of the circular path: \\[ r_L = \\frac{m v_0}{q B} \\] In this case, the velocity vector is always perpendicular to the magnetic field, and the motion is purely circular. 2. Combined Electric and Magnetic Fields (Helical Motion): When both electric and magnetic fields are applied, the particle will follow a helical path. The magnetic field causes the particle to move in a circular motion, while the electric field accelerates the particle along the field lines, resulting in a spiral trajectory. 3. Crossed Electric and Magnetic Fields (Drift Motion): If the electric and magnetic fields are perpendicular to each other, the particle will experience drift motion . In this scenario, the particle\u2019s motion is governed by the E \u00d7 B drift , where the particle moves with a constant drift velocity perpendicular to both fields. 4. Effect of Parameter Variations: The trajectory of the particle is sensitive to variations in the following parameters: Field Strengths : Increasing the magnetic field strength \\(B\\) leads to a smaller radius of curvature, while increasing the electric field strength \\(E\\) will accelerate the particle. Initial Velocity : A higher initial velocity \\(v_0\\) results in larger, less curved paths. Particle Mass and Charge : A larger mass results in a larger radius of curvature, while a larger charge leads to a stronger Lorentz force and thus a smaller radius. Visualization: The simulation will produce 2D and 3D plots of the particle's trajectory for the different field configurations. Key features like the Larmor radius and drift velocity will be highlighted to visualize how these physical parameters influence the motion. Deliverables: Markdown document with detailed explanation and Python code for the simulation. Visualizations of particle trajectories in 2D and 3D for various scenarios (circular motion, helical motion, drift motion). A discussion on how the simulation results can be applied to practical systems like cyclotrons , mass spectrometers , and magnetic confinement devices . import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from matplotlib.collections import LineCollection # === Constants === q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # === Initial conditions === r0 = np.array([1.0, 0.0, 0.0]) # Initial position (m) v0 = np.array([0.0, 1.0, 0.0]) # Initial velocity perpendicular to B (m/s) y0 = np.concatenate((r0, v0)) # Combine position and velocity # === Lorentz force differential equation === def lorentz(t, y): r = y[:3] v = y[3:] dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((v, dvdt)) # === Time setup === t_span = (0, 10) t_eval = np.linspace(*t_span, 500) sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) x, y = sol.y[0], sol.y[1] # === Color gradient path === points = np.array([x, y]).T.reshape(-1, 1, 2) segments = np.concatenate([points[:-1], points[1:]], axis=1) norm = plt.Normalize(t_eval.min(), t_eval.max()) lc = LineCollection(segments, cmap='plasma', norm=norm) lc.set_array(t_eval) lc.set_linewidth(2.5) # === Plot === fig, ax = plt.subplots(figsize=(8, 6)) ax.add_collection(lc) ax.scatter(x[0], y[0], color='lime', label='Start', zorder=5) ax.scatter(x[-1], y[-1], color='red', label='End', zorder=5) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Circular Trajectory in Magnetic Field', weight='bold') ax.axis('equal') axcb = fig.colorbar(lc, ax=ax, label='Time (s)') ax.legend() plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from scipy.integrate import solve_ivp from IPython.display import Image, display # === Constants === q = 1.0 # Charge (C) m = 1.0 # Mass (kg) \u2014 1 gram = 0.001 kg E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # === Initial Conditions === v0 = np.array([1.0, 0.0, 0.0]) # Velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # Position (m) y0 = np.concatenate((r0, v0)) # Combine initial state # === Lorentz Force Function === def lorentz(t, y): r = y[:3] v = y[3:] dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((v, dvdt)) # === Time Settings === t_span = (0, 10) t_eval = np.linspace(t_span[0], t_span[1], 500) sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) x, y = sol.y[0], sol.y[1] # only x and y components for 2D plot z = sol.y[2] # z component (flat in circular motion) # === Set Up Plot === fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(np.min(x)*1.1, np.max(x)*1.1) ax.set_ylim(np.min(y)*1.1, np.max(y)*1.1) ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_title(\"Charged Particle Motion in 2D (x-y plane)\") ax.grid(True) line, = ax.plot([], [], lw=2, color='dodgerblue') point, = ax.plot([], [], 'ro') # === Init Function === def init(): line.set_data([], []) point.set_data([], []) return line, point # === Update Function === def update(i): if i < len(x): line.set_data(x[:i+1], y[:i+1]) point.set_data([x[i]], [y[i]]) return line, point # === Create Animation === ani = FuncAnimation(fig, update, frames=len(x), init_func=init, blit=False, interval=20) # === Save to GIF === gif_path = \"charged_particle_motion.gif\" writer = PillowWriter(fps=30) ani.save(gif_path, writer=writer, dpi=100) plt.close() # === Display in Notebook (if using Jupyter/Colab) === display(Image(filename=gif_path)) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm # Constants q = 1.0 m = 1.0 E = np.array([0.0, 0.0, 1.0]) B = np.array([0.0, 0.0, 1.0]) # Initial conditions v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) y0 = np.concatenate((v0, r0)) # Lorentz force function def lorentz(t, y): v = y[:3] r = y[3:] dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((dvdt, v)) # Solve system t_span = (0, 10) t_eval = np.linspace(*t_span, 1000) sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) x, y, z = sol.y[3], sol.y[4], sol.y[5] # 3D Plot fig = plt.figure(figsize=(12, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(x, y, z, lw=2, c='grey', alpha=0.3) scatter = ax.scatter(x, y, z, c=sol.t, cmap='viridis', s=2) ax.scatter(x[0], y[0], z[0], color='lime', label='Start', s=60) ax.scatter(x[-1], y[-1], z[-1], color='red', label='End', s=60) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') ax.set_title('3D Trajectory of a Charged Particle\\nin Electric & Magnetic Fields', weight='bold', fontsize=14) fig.colorbar(scatter, ax=ax, label='Time (s)', shrink=0.6, pad=0.1) plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants q = 1.0 # charge m = 1.0 # mass E = np.array([1.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field # Initial conditions v0 = np.array([0.0, 1.0, 0.0]) # Initial velocity r0 = np.array([0.0, 0.0, 0.0]) # Initial position y0 = np.concatenate((v0, r0)) # Lorentz force equation def lorentz(t, y): v = y[:3] r = y[3:] dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((dvdt, v)) # Time settings t_span = (0, 20) t_eval = np.linspace(*t_span, 2000) # Solve the ODE sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) x, y, z = sol.y[3], sol.y[4], sol.y[5] # Plotting fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.set_facecolor('black') fig.patch.set_facecolor('black') # Plot the trajectory ax.plot(x, y, z, color='orange', label='Drift Motion') # Labels and style ax.set_xlabel('x (m)', color='white') ax.set_ylabel('y (m)', color='white') ax.set_zlabel('z (m)', color='white') ax.tick_params(colors='white') ax.xaxis.label.set_color('white') ax.yaxis.label.set_color('white') ax.zaxis.label.set_color('white') ax.legend(loc='upper right', facecolor='black', edgecolor='white', labelcolor='white') # Adjust the grid and background ax.grid(True, color='gray', linestyle='--', alpha=0.5) plt.title(\"Drift Motion\", color='white', fontsize=14) plt.show()","title":"Electromagnetism"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism","text":"","title":"Electromagnetism"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1-simulating-the-effects-of-the-lorentz-force","text":"","title":"Problem 1: Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#introduction","text":"The Lorentz force is the force experienced by a charged particle due to electromagnetic fields. It is a fundamental concept in electromagnetism and governs the behavior of particles in many physical systems. The force is given by the following equation: \\[ \\mathbf{F} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] Where: - \\(\\mathbf{F}\\) is the force on the particle, - \\(q\\) is the charge of the particle, - \\(\\mathbf{E}\\) is the electric field, - \\(\\mathbf{v}\\) is the velocity of the particle, - \\(\\mathbf{B}\\) is the magnetic field. The Lorentz force is responsible for the motion of charged particles in systems such as particle accelerators , mass spectrometers , plasma confinement devices , and magnetic traps . This task focuses on simulating the effects of this force on the motion of a particle under different electromagnetic field configurations.","title":"Introduction:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#physical-parameters","text":"To simplify the simulation and avoid subatomic-scale complexities, we define the following parameters for the charged particle: Charge \\(q = 1 \\, \\text{C}\\) : The charge of the particle is set to 1 Coulomb. Mass \\(m = 1 \\, \\text{g} = 1 \\times 10^{-3} \\, \\text{kg}\\) : The particle\u2019s mass is set to 1 gram. Magnetic Field \\(\\mathbf{B} = [0, 0, 1] \\, \\text{T}\\) : A uniform magnetic field along the \\(z\\) -axis (1 Tesla). Electric Field \\(\\mathbf{E} = [0, 0, 0] \\, \\text{V/m}\\) : Initially, no electric field is applied. Initial Velocity \\(\\mathbf{v_0} = [1, 0, 0] \\, \\text{m/s}\\) : The particle starts with an initial velocity of 1 m/s along the \\(x\\) -axis. Initial Position \\(\\mathbf{r_0} = [0, 0, 0] \\, \\text{m}\\) : The particle starts at the origin. These parameters define the initial conditions for the simulation and are key to understanding how different configurations of electric and magnetic fields affect particle motion.","title":"Physical Parameters:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#equations-of-motion","text":"The Lorentz force law governs the motion of the particle. The equations of motion for a charged particle in electromagnetic fields are: \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] \\[ \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m} \\left( \\mathbf{E} + \\mathbf{v} \\times \\mathbf{B} \\right) \\] Where: - \\(\\mathbf{r}\\) is the particle\u2019s position, - \\(\\mathbf{v}\\) is the particle\u2019s velocity, - \\(\\mathbf{E}\\) is the electric field, - \\(\\mathbf{B}\\) is the magnetic field, - \\(\\mathbf{F}\\) is the Lorentz force. The first equation describes how the position of the particle changes over time, and the second equation governs the velocity change due to the Lorentz force. These differential equations are solved numerically to simulate the particle's trajectory over time.","title":"Equations of Motion:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenarios-and-trajectories","text":"","title":"Scenarios and Trajectories:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-uniform-magnetic-field-circular-motion","text":"When only a magnetic field is present, the charged particle moves in a circular trajectory perpendicular to the magnetic field. The Larmor radius describes the radius of the circular path: \\[ r_L = \\frac{m v_0}{q B} \\] In this case, the velocity vector is always perpendicular to the magnetic field, and the motion is purely circular.","title":"1. Uniform Magnetic Field (Circular Motion):"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-combined-electric-and-magnetic-fields-helical-motion","text":"When both electric and magnetic fields are applied, the particle will follow a helical path. The magnetic field causes the particle to move in a circular motion, while the electric field accelerates the particle along the field lines, resulting in a spiral trajectory.","title":"2. Combined Electric and Magnetic Fields (Helical Motion):"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-crossed-electric-and-magnetic-fields-drift-motion","text":"If the electric and magnetic fields are perpendicular to each other, the particle will experience drift motion . In this scenario, the particle\u2019s motion is governed by the E \u00d7 B drift , where the particle moves with a constant drift velocity perpendicular to both fields.","title":"3. Crossed Electric and Magnetic Fields (Drift Motion):"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-effect-of-parameter-variations","text":"The trajectory of the particle is sensitive to variations in the following parameters: Field Strengths : Increasing the magnetic field strength \\(B\\) leads to a smaller radius of curvature, while increasing the electric field strength \\(E\\) will accelerate the particle. Initial Velocity : A higher initial velocity \\(v_0\\) results in larger, less curved paths. Particle Mass and Charge : A larger mass results in a larger radius of curvature, while a larger charge leads to a stronger Lorentz force and thus a smaller radius.","title":"4. Effect of Parameter Variations:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#visualization","text":"The simulation will produce 2D and 3D plots of the particle's trajectory for the different field configurations. Key features like the Larmor radius and drift velocity will be highlighted to visualize how these physical parameters influence the motion.","title":"Visualization:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables","text":"Markdown document with detailed explanation and Python code for the simulation. Visualizations of particle trajectories in 2D and 3D for various scenarios (circular motion, helical motion, drift motion). A discussion on how the simulation results can be applied to practical systems like cyclotrons , mass spectrometers , and magnetic confinement devices .","title":"Deliverables:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#_1","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from matplotlib.collections import LineCollection # === Constants === q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # === Initial conditions === r0 = np.array([1.0, 0.0, 0.0]) # Initial position (m) v0 = np.array([0.0, 1.0, 0.0]) # Initial velocity perpendicular to B (m/s) y0 = np.concatenate((r0, v0)) # Combine position and velocity # === Lorentz force differential equation === def lorentz(t, y): r = y[:3] v = y[3:] dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((v, dvdt)) # === Time setup === t_span = (0, 10) t_eval = np.linspace(*t_span, 500) sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) x, y = sol.y[0], sol.y[1] # === Color gradient path === points = np.array([x, y]).T.reshape(-1, 1, 2) segments = np.concatenate([points[:-1], points[1:]], axis=1) norm = plt.Normalize(t_eval.min(), t_eval.max()) lc = LineCollection(segments, cmap='plasma', norm=norm) lc.set_array(t_eval) lc.set_linewidth(2.5) # === Plot === fig, ax = plt.subplots(figsize=(8, 6)) ax.add_collection(lc) ax.scatter(x[0], y[0], color='lime', label='Start', zorder=5) ax.scatter(x[-1], y[-1], color='red', label='End', zorder=5) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Circular Trajectory in Magnetic Field', weight='bold') ax.axis('equal') axcb = fig.colorbar(lc, ax=ax, label='Time (s)') ax.legend() plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#_2","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from scipy.integrate import solve_ivp from IPython.display import Image, display # === Constants === q = 1.0 # Charge (C) m = 1.0 # Mass (kg) \u2014 1 gram = 0.001 kg E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # === Initial Conditions === v0 = np.array([1.0, 0.0, 0.0]) # Velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # Position (m) y0 = np.concatenate((r0, v0)) # Combine initial state # === Lorentz Force Function === def lorentz(t, y): r = y[:3] v = y[3:] dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((v, dvdt)) # === Time Settings === t_span = (0, 10) t_eval = np.linspace(t_span[0], t_span[1], 500) sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) x, y = sol.y[0], sol.y[1] # only x and y components for 2D plot z = sol.y[2] # z component (flat in circular motion) # === Set Up Plot === fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(np.min(x)*1.1, np.max(x)*1.1) ax.set_ylim(np.min(y)*1.1, np.max(y)*1.1) ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_title(\"Charged Particle Motion in 2D (x-y plane)\") ax.grid(True) line, = ax.plot([], [], lw=2, color='dodgerblue') point, = ax.plot([], [], 'ro') # === Init Function === def init(): line.set_data([], []) point.set_data([], []) return line, point # === Update Function === def update(i): if i < len(x): line.set_data(x[:i+1], y[:i+1]) point.set_data([x[i]], [y[i]]) return line, point # === Create Animation === ani = FuncAnimation(fig, update, frames=len(x), init_func=init, blit=False, interval=20) # === Save to GIF === gif_path = \"charged_particle_motion.gif\" writer = PillowWriter(fps=30) ani.save(gif_path, writer=writer, dpi=100) plt.close() # === Display in Notebook (if using Jupyter/Colab) === display(Image(filename=gif_path))","title":""},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#_3","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm # Constants q = 1.0 m = 1.0 E = np.array([0.0, 0.0, 1.0]) B = np.array([0.0, 0.0, 1.0]) # Initial conditions v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) y0 = np.concatenate((v0, r0)) # Lorentz force function def lorentz(t, y): v = y[:3] r = y[3:] dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((dvdt, v)) # Solve system t_span = (0, 10) t_eval = np.linspace(*t_span, 1000) sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) x, y, z = sol.y[3], sol.y[4], sol.y[5] # 3D Plot fig = plt.figure(figsize=(12, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(x, y, z, lw=2, c='grey', alpha=0.3) scatter = ax.scatter(x, y, z, c=sol.t, cmap='viridis', s=2) ax.scatter(x[0], y[0], z[0], color='lime', label='Start', s=60) ax.scatter(x[-1], y[-1], z[-1], color='red', label='End', s=60) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') ax.set_title('3D Trajectory of a Charged Particle\\nin Electric & Magnetic Fields', weight='bold', fontsize=14) fig.colorbar(scatter, ax=ax, label='Time (s)', shrink=0.6, pad=0.1) plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#_4","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants q = 1.0 # charge m = 1.0 # mass E = np.array([1.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field # Initial conditions v0 = np.array([0.0, 1.0, 0.0]) # Initial velocity r0 = np.array([0.0, 0.0, 0.0]) # Initial position y0 = np.concatenate((v0, r0)) # Lorentz force equation def lorentz(t, y): v = y[:3] r = y[3:] dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((dvdt, v)) # Time settings t_span = (0, 20) t_eval = np.linspace(*t_span, 2000) # Solve the ODE sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) x, y, z = sol.y[3], sol.y[4], sol.y[5] # Plotting fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.set_facecolor('black') fig.patch.set_facecolor('black') # Plot the trajectory ax.plot(x, y, z, color='orange', label='Drift Motion') # Labels and style ax.set_xlabel('x (m)', color='white') ax.set_ylabel('y (m)', color='white') ax.set_zlabel('z (m)', color='white') ax.tick_params(colors='white') ax.xaxis.label.set_color('white') ax.yaxis.label.set_color('white') ax.zaxis.label.set_color('white') ax.legend(loc='upper right', facecolor='black', edgecolor='white', labelcolor='white') # Adjust the grid and background ax.grid(True, color='gray', linestyle='--', alpha=0.5) plt.title(\"Drift Motion\", color='white', fontsize=14) plt.show()","title":""},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}