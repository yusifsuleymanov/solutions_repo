{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 # Theoretical Foundation Derivation of Projectile Motion from Newton's Laws We begin by considering a projectile launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) above the horizontal. The motion can be decomposed into two perpendicular components: Horizontal (x-axis) Vertical (y-axis) Assumptions: No air resistance Constant gravitational acceleration \\(g\\) Launched from the origin at time \\(t = 0\\) 1. Equations of Motion Horizontal motion (constant velocity): Acceleration: \\(a_x=0\\) Velocity: \\(v_x=v_0\\cos(\\theta)\\) Displacement: \\( \\(x(t)=v_0\\cos(\\theta)\\cdot t\\) \\) Vertical motion (accelerated motion): Acceleration: \\(a_y=-g\\) Velocity: \\(v_y=v_0\\sin(\\theta)-gt\\) Displacement: \\( \\(y(t)=v_0\\sin(\\theta)\\cdot t-\\frac{1}{2}gt^2\\) \\) 2. Time of Flight The projectile hits the ground when \\(y(t) = 0\\) . Solving: \\[ v_0\\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 = 0 \\] \\[ t(v_0\\sin(\\theta) - \\frac{1}{2}gt) = 0 \\] Non-zero solution: \\[ t = \\frac{2v_0\\sin(\\theta)}{g} \\] \u2194 3. Horizontal Range \\(R\\) Substitute the total time of flight into the horizontal displacement: \\[ R = x(t) = v_0\\cos(\\theta) \\cdot \\frac{2v_0\\sin(\\theta)}{g} \\] \\[ \\boxed{R = \\frac{v_0^2\\sin(2\\theta)}{g}} \\] This shows that range is maximum when \\(\\sin(2\\theta) = 1\\) , i.e. \\(\\theta = 45^\\circ\\) 4. Effect of Initial Conditions on Range Initial Velocity \\(v_0\\) : Range is proportional to \\(v_0^2\\) Doubling speed increases range fourfold Angle \\(\\theta\\) : Affects both vertical and horizontal components Maximum range at \\(\\theta = 45^\\circ\\) (in symmetric conditions) Gravitational Acceleration \\(g\\) : Inverse relation: higher gravity \u2192 shorter range Launch Height (not included above) : Adds vertical displacement Increases total time in air \u2192 longer range (needs new derivation) These equations form the idealized model of projectile motion, laying the foundation for further numerical or simulation-based analysis. Analysis of the Range 1. Mathematical Relationship Between Range and Angle Using the derived formula from earlier: \\[ R=\\frac{v_0^2\\sin(2\\theta)}{g} \\] Where: - \\(R\\) is the horizontal range - \\(v_0\\) is the initial velocity - \\(\\theta\\) is the launch angle - \\(g\\) is the acceleration due to gravity Key Observations: Range depends non-linearly on \\(\u03b8\\) through \\(sin(2\u03b8)\\) . The function \\(sin(2\u03b8)\\) reaches its maximum value of 1 when \\(2\u03b8=90\u00b0\\) . Therefore, the maximum range occurs at: \\( \\(\\boxed{\u03b8=45\u00b0}\\) \\) 2. Effect of Initial Velocity ( \\(v_0\\) ) From the formula: \\[ R\\propto v_0^2 \\] Doubling \\(v_0\\) quadruples the range. Plotting range vs. angle for different velocities shifts the amplitude of the curve but not the position of the peak. 3. Effect of Gravitational Acceleration ( \\(g\\) ) Range is inversely proportional to \\(g\\) : \\[ R\\propto\\frac{1}{g} \\] Lower gravity (e.g., on the Moon) results in a longer range . Higher gravity (e.g., on Jupiter) produces a shorter range . 4. Launch Height (Advanced) When the projectile is launched from a height \\(h>0\\) , total time of flight increases. The vertical displacement becomes: \\[ y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2+h \\] To find time of flight \\(t_f\\) , solve: \\[ 0=h+v_0\\sin(\\theta)t_f-\\frac{1}{2}gt_f^2 \\] This is a quadratic in \\(t_f\\) : \\[ \\frac{1}{2}gt_f^2-v_0\\sin(\\theta)t_f-h=0 \\] Solve for \\(t_f\\) using the quadratic formula: \\[ t_f=\\frac{v_0\\sin(\\theta)+\\sqrt{(v_0\\sin(\\theta))^2+2gh}}{g} \\] Then calculate range: \\[ R=v_0\\cos(\\theta)\\cdot t_f \\] Note: Range increases with height. The angle for maximum range no longer remains 45\u00b0 when launching from a height. Summary Parameter Effect on Range Initial Velocity \\(v_0\\) Quadratic increase ( \\(\\propto v_0^2\\) ) Launch Angle \\(\\theta\\) Max at \\(45^\\circ\\) (flat launch) Gravity \\(g\\) Inversely proportional Launch Height \\(h\\) Increases range, changes optimal angle This analysis provides a full picture of how the range responds to varying parameters in ideal and slightly more realistic conditions. Practical Applications of Projectile Motion 1. Real-World Situations Involving Projectile Motion Projectile motion is observed in various natural and engineered systems: Sports: A soccer ball, basketball, or javelin follows a projectile path after being launched. The initial velocity and launch angle determine whether the ball reaches the goal or basket. Engineering: Water fountains or fire hoses arc based on launch parameters. Ballistics in defense and aerospace engineering heavily depend on accurate projectile modeling. Astrophysics: Space missions use orbital mechanics \u2014 an extension of projectile motion under gravity. Launching a probe involves solving similar equations in non-Earth gravity fields. 2. Effects of Terrain, Drag, and Wind a. Uneven Terrain When projectiles land on non-flat surfaces , the simple range formula no longer applies. Suppose the landing height is different from the launch height \\(h_0\\) , then total time of flight \\(t_f\\) must be found by solving: \\[ y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2+h_0 \\] Final range becomes: \\[ R=v_0\\cos(\\theta)\\cdot t_f \\] Requires solving a quadratic equation for \\(t_f\\) and using it in range computation. b. Air Resistance (Drag) Real trajectories are affected by drag force proportional to velocity: \\[ F_d=-kv \\] Where: - \\(F_d\\) is the drag force, - \\(k\\) is a constant depending on air density and shape, - \\(v\\) is velocity. This leads to nonlinear differential equations : In horizontal direction: \\[m\\frac{dv_x}{dt}=-kv_x\\] In vertical direction: \\[m\\frac{dv_y}{dt}=-mg-kv_y\\] These must be solved numerically using techniques like Euler\u2019s method or Runge-Kutta. c. Wind Wind introduces additional velocity components: - Tailwind increases range. - Headwind decreases range. - Crosswind changes the direction of the projectile, affecting accuracy. Effective horizontal velocity becomes: \\[ v_{\\text{effective}}=v_0\\cos(\\theta)\\pm v_{\\text{wind}} \\] 3. Adapting the Model To make the model more realistic: Include drag : Use numerical simulation (e.g., Runge-Kutta) to solve motion with air resistance. Include wind : Modify initial velocity vector to account for wind speed and direction. Simulate terrain : Adjust impact height based on known terrain elevation data. Summary Realistic Factor Effect on Range Modeling Approach Uneven Terrain Alters time of flight Quadratic equation with height offset Air Resistance Shortens range significantly Numerical solution of ODEs Wind Alters path and accuracy Adjust velocity components By expanding our model, we bridge the gap between ideal physics and real-world scenarios, increasing the accuracy and relevance of projectile analysis. Implementation: Computational Simulation of Projectile Motion This section provides a Python implementation to simulate projectile motion, analyze the range as a function of angle, and visualize the effects of varying initial conditions. Objective Simulate projectile motion under ideal conditions. Plot Range vs. Angle of Projection . Allow the user to vary: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Initial height \\(h_0\\) Python Code (Jupyter Notebook Compatible) import numpy as np import matplotlib.pyplot as plt # --- Function to calculate range --- def calculate_range(v0, angle_deg, g=9.81, h0=0): angle_rad = np.radians(angle_deg) v0x = v0 * np.cos(angle_rad) v0y = v0 * np.sin(angle_rad) if h0 == 0: # Flat terrain (simplified range formula) R = (v0**2 * np.sin(2 * angle_rad)) / g else: # Non-zero launch height, solve for time of flight and range t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g R = v0x * t_flight return R # --- Function to simulate and plot --- def plot_range_vs_angle(v0, g=9.81, h0=0): angles = np.linspace(0, 90, 500) ranges = [calculate_range(v0, angle, g, h0) for angle in angles] plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, label=f'v\u2080={v0} m/s, g={g} m/s\u00b2, h\u2080={h0} m') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.show() # --- Example usage --- # Modify these parameters to explore different conditions initial_velocity = 30 # m/s gravity = 9.81 # m/s\u00b2 initial_height = 0 # m plot_range_vs_angle(initial_velocity, gravity, initial_height) import numpy as np import matplotlib.pyplot as plt # --- Function to calculate range --- def calculate_range(v0, angle_deg, g=9.81, h0=0): angle_rad = np.radians(angle_deg) v0x = v0 * np.cos(angle_rad) v0y = v0 * np.sin(angle_rad) if h0 == 0: # Flat terrain (simplified range formula) R = (v0**2 * np.sin(2 * angle_rad)) / g else: # Non-zero launch height, solve for time of flight and range t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g R = v0x * t_flight return R # --- Function to simulate and plot --- def plot_range_vs_angle(v0_values, g=9.81, h0=0): angles = np.linspace(0, 90, 500) plt.figure(figsize=(12, 7)) for v0 in v0_values: ranges = [calculate_range(v0, angle, g, h0) for angle in angles] plt.plot(angles, ranges, label=f'v\u2080 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.title('Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.tight_layout() plt.show() # --- Example usage --- initial_velocities = [10, 20, 30, 40, 50] # m/s gravity = 9.81 # m/s\u00b2 (Earth) initial_height = 0 # m (ground level launch) plot_range_vs_angle(initial_velocities, gravity, initial_height) import numpy as np import matplotlib.pyplot as plt # Function to simulate projectile motion def projectile_motion(v0, angle_deg, g=9.81, h0=0): angle_rad = np.radians(angle_deg) v0x = v0 * np.cos(angle_rad) v0y = v0 * np.sin(angle_rad) # Time of flight if h0 == 0: t_flight = 2 * v0y / g else: t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g t = np.linspace(0, t_flight, num=300) x = v0x * t y = h0 + v0y * t - 0.5 * g * t**2 return x, y # Plot setup g = 9.81 h0 = 0 fig, axs = plt.subplots(2, 1, figsize=(10, 12)) # (a) Fixed angle, changing speeds velocities = [30, 40, 50] angle_fixed = 45 colors = ['r', 'purple', 'green'] for v0, color in zip(velocities, colors): x, y = projectile_motion(v0, angle_fixed, g, h0) axs[0].plot(x, y, color=color, label=f'v\u2080 = {v0} m/s') axs[0].set_title('(a) Constant Angle (45\u00b0), Varying Speeds') axs[0].set_xlabel('x (meters)') axs[0].set_ylabel('y (meters)') axs[0].legend() axs[0].grid(True) axs[0].axis('equal') # (b) Fixed speed, changing angles v0_fixed = 50 angles = [15, 45, 75] for angle, color in zip(angles, colors): x, y = projectile_motion(v0_fixed, angle, g, h0) axs[1].plot(x, y, color=color, label=f'\u03b8 = {angle}\u00b0') axs[1].set_title('(b) Constant Speed (50 m/s), Varying Angles') axs[1].set_xlabel('x (meters)') axs[1].set_ylabel('y (meters)') axs[1].legend() axs[1].grid(True) axs[1].axis('equal') plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-projectile-motion-from-newtons-laws","text":"We begin by considering a projectile launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) above the horizontal. The motion can be decomposed into two perpendicular components: Horizontal (x-axis) Vertical (y-axis)","title":"Derivation of Projectile Motion from Newton's Laws"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#assumptions","text":"No air resistance Constant gravitational acceleration \\(g\\) Launched from the origin at time \\(t = 0\\)","title":"Assumptions:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-equations-of-motion","text":"Horizontal motion (constant velocity): Acceleration: \\(a_x=0\\) Velocity: \\(v_x=v_0\\cos(\\theta)\\) Displacement: \\( \\(x(t)=v_0\\cos(\\theta)\\cdot t\\) \\) Vertical motion (accelerated motion): Acceleration: \\(a_y=-g\\) Velocity: \\(v_y=v_0\\sin(\\theta)-gt\\) Displacement: \\( \\(y(t)=v_0\\sin(\\theta)\\cdot t-\\frac{1}{2}gt^2\\) \\)","title":"1. Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-time-of-flight","text":"The projectile hits the ground when \\(y(t) = 0\\) . Solving: \\[ v_0\\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 = 0 \\] \\[ t(v_0\\sin(\\theta) - \\frac{1}{2}gt) = 0 \\] Non-zero solution: \\[ t = \\frac{2v_0\\sin(\\theta)}{g} \\]","title":"2. Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-horizontal-range-r","text":"Substitute the total time of flight into the horizontal displacement: \\[ R = x(t) = v_0\\cos(\\theta) \\cdot \\frac{2v_0\\sin(\\theta)}{g} \\] \\[ \\boxed{R = \\frac{v_0^2\\sin(2\\theta)}{g}} \\] This shows that range is maximum when \\(\\sin(2\\theta) = 1\\) , i.e. \\(\\theta = 45^\\circ\\)","title":"\u2194 3. Horizontal Range \\(R\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-effect-of-initial-conditions-on-range","text":"Initial Velocity \\(v_0\\) : Range is proportional to \\(v_0^2\\) Doubling speed increases range fourfold Angle \\(\\theta\\) : Affects both vertical and horizontal components Maximum range at \\(\\theta = 45^\\circ\\) (in symmetric conditions) Gravitational Acceleration \\(g\\) : Inverse relation: higher gravity \u2192 shorter range Launch Height (not included above) : Adds vertical displacement Increases total time in air \u2192 longer range (needs new derivation)","title":"4. Effect of Initial Conditions on Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#these-equations-form-the-idealized-model-of-projectile-motion-laying-the-foundation-for-further-numerical-or-simulation-based-analysis","text":"","title":"These equations form the idealized model of projectile motion, laying the foundation for further numerical or simulation-based analysis."},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis-of-the-range","text":"","title":"Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-mathematical-relationship-between-range-and-angle","text":"Using the derived formula from earlier: \\[ R=\\frac{v_0^2\\sin(2\\theta)}{g} \\] Where: - \\(R\\) is the horizontal range - \\(v_0\\) is the initial velocity - \\(\\theta\\) is the launch angle - \\(g\\) is the acceleration due to gravity","title":"1. Mathematical Relationship Between Range and Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-observations","text":"Range depends non-linearly on \\(\u03b8\\) through \\(sin(2\u03b8)\\) . The function \\(sin(2\u03b8)\\) reaches its maximum value of 1 when \\(2\u03b8=90\u00b0\\) . Therefore, the maximum range occurs at: \\( \\(\\boxed{\u03b8=45\u00b0}\\) \\)","title":"Key Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-effect-of-initial-velocity-v_0","text":"From the formula: \\[ R\\propto v_0^2 \\] Doubling \\(v_0\\) quadruples the range. Plotting range vs. angle for different velocities shifts the amplitude of the curve but not the position of the peak.","title":"2. Effect of Initial Velocity (\\(v_0\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-effect-of-gravitational-acceleration-g","text":"Range is inversely proportional to \\(g\\) : \\[ R\\propto\\frac{1}{g} \\] Lower gravity (e.g., on the Moon) results in a longer range . Higher gravity (e.g., on Jupiter) produces a shorter range .","title":"3. Effect of Gravitational Acceleration (\\(g\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-launch-height-advanced","text":"When the projectile is launched from a height \\(h>0\\) , total time of flight increases. The vertical displacement becomes: \\[ y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2+h \\] To find time of flight \\(t_f\\) , solve: \\[ 0=h+v_0\\sin(\\theta)t_f-\\frac{1}{2}gt_f^2 \\] This is a quadratic in \\(t_f\\) : \\[ \\frac{1}{2}gt_f^2-v_0\\sin(\\theta)t_f-h=0 \\] Solve for \\(t_f\\) using the quadratic formula: \\[ t_f=\\frac{v_0\\sin(\\theta)+\\sqrt{(v_0\\sin(\\theta))^2+2gh}}{g} \\] Then calculate range: \\[ R=v_0\\cos(\\theta)\\cdot t_f \\]","title":"4. Launch Height (Advanced)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#note","text":"Range increases with height. The angle for maximum range no longer remains 45\u00b0 when launching from a height.","title":"Note:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#summary","text":"Parameter Effect on Range Initial Velocity \\(v_0\\) Quadratic increase ( \\(\\propto v_0^2\\) ) Launch Angle \\(\\theta\\) Max at \\(45^\\circ\\) (flat launch) Gravity \\(g\\) Inversely proportional Launch Height \\(h\\) Increases range, changes optimal angle","title":"Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#this-analysis-provides-a-full-picture-of-how-the-range-responds-to-varying-parameters-in-ideal-and-slightly-more-realistic-conditions","text":"","title":"This analysis provides a full picture of how the range responds to varying parameters in ideal and slightly more realistic conditions."},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications-of-projectile-motion","text":"","title":"Practical Applications of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-real-world-situations-involving-projectile-motion","text":"Projectile motion is observed in various natural and engineered systems: Sports: A soccer ball, basketball, or javelin follows a projectile path after being launched. The initial velocity and launch angle determine whether the ball reaches the goal or basket. Engineering: Water fountains or fire hoses arc based on launch parameters. Ballistics in defense and aerospace engineering heavily depend on accurate projectile modeling. Astrophysics: Space missions use orbital mechanics \u2014 an extension of projectile motion under gravity. Launching a probe involves solving similar equations in non-Earth gravity fields.","title":"1. Real-World Situations Involving Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-effects-of-terrain-drag-and-wind","text":"","title":"2. Effects of Terrain, Drag, and Wind"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#a-uneven-terrain","text":"When projectiles land on non-flat surfaces , the simple range formula no longer applies. Suppose the landing height is different from the launch height \\(h_0\\) , then total time of flight \\(t_f\\) must be found by solving: \\[ y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2+h_0 \\] Final range becomes: \\[ R=v_0\\cos(\\theta)\\cdot t_f \\] Requires solving a quadratic equation for \\(t_f\\) and using it in range computation.","title":"a. Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#b-air-resistance-drag","text":"Real trajectories are affected by drag force proportional to velocity: \\[ F_d=-kv \\] Where: - \\(F_d\\) is the drag force, - \\(k\\) is a constant depending on air density and shape, - \\(v\\) is velocity. This leads to nonlinear differential equations : In horizontal direction: \\[m\\frac{dv_x}{dt}=-kv_x\\] In vertical direction: \\[m\\frac{dv_y}{dt}=-mg-kv_y\\] These must be solved numerically using techniques like Euler\u2019s method or Runge-Kutta.","title":"b. Air Resistance (Drag)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#c-wind","text":"Wind introduces additional velocity components: - Tailwind increases range. - Headwind decreases range. - Crosswind changes the direction of the projectile, affecting accuracy. Effective horizontal velocity becomes: \\[ v_{\\text{effective}}=v_0\\cos(\\theta)\\pm v_{\\text{wind}} \\]","title":"c. Wind"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-adapting-the-model","text":"To make the model more realistic: Include drag : Use numerical simulation (e.g., Runge-Kutta) to solve motion with air resistance. Include wind : Modify initial velocity vector to account for wind speed and direction. Simulate terrain : Adjust impact height based on known terrain elevation data.","title":"3. Adapting the Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#summary_1","text":"Realistic Factor Effect on Range Modeling Approach Uneven Terrain Alters time of flight Quadratic equation with height offset Air Resistance Shortens range significantly Numerical solution of ODEs Wind Alters path and accuracy Adjust velocity components By expanding our model, we bridge the gap between ideal physics and real-world scenarios, increasing the accuracy and relevance of projectile analysis.","title":"Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation-computational-simulation-of-projectile-motion","text":"This section provides a Python implementation to simulate projectile motion, analyze the range as a function of angle, and visualize the effects of varying initial conditions.","title":"Implementation: Computational Simulation of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#objective","text":"Simulate projectile motion under ideal conditions. Plot Range vs. Angle of Projection . Allow the user to vary: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Initial height \\(h_0\\)","title":"Objective"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-jupyter-notebook-compatible","text":"","title":"Python Code (Jupyter Notebook Compatible)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_1","text":"import numpy as np import matplotlib.pyplot as plt # --- Function to calculate range --- def calculate_range(v0, angle_deg, g=9.81, h0=0): angle_rad = np.radians(angle_deg) v0x = v0 * np.cos(angle_rad) v0y = v0 * np.sin(angle_rad) if h0 == 0: # Flat terrain (simplified range formula) R = (v0**2 * np.sin(2 * angle_rad)) / g else: # Non-zero launch height, solve for time of flight and range t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g R = v0x * t_flight return R # --- Function to simulate and plot --- def plot_range_vs_angle(v0, g=9.81, h0=0): angles = np.linspace(0, 90, 500) ranges = [calculate_range(v0, angle, g, h0) for angle in angles] plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, label=f'v\u2080={v0} m/s, g={g} m/s\u00b2, h\u2080={h0} m') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.show() # --- Example usage --- # Modify these parameters to explore different conditions initial_velocity = 30 # m/s gravity = 9.81 # m/s\u00b2 initial_height = 0 # m plot_range_vs_angle(initial_velocity, gravity, initial_height)","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_2","text":"import numpy as np import matplotlib.pyplot as plt # --- Function to calculate range --- def calculate_range(v0, angle_deg, g=9.81, h0=0): angle_rad = np.radians(angle_deg) v0x = v0 * np.cos(angle_rad) v0y = v0 * np.sin(angle_rad) if h0 == 0: # Flat terrain (simplified range formula) R = (v0**2 * np.sin(2 * angle_rad)) / g else: # Non-zero launch height, solve for time of flight and range t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g R = v0x * t_flight return R # --- Function to simulate and plot --- def plot_range_vs_angle(v0_values, g=9.81, h0=0): angles = np.linspace(0, 90, 500) plt.figure(figsize=(12, 7)) for v0 in v0_values: ranges = [calculate_range(v0, angle, g, h0) for angle in angles] plt.plot(angles, ranges, label=f'v\u2080 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.title('Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.tight_layout() plt.show() # --- Example usage --- initial_velocities = [10, 20, 30, 40, 50] # m/s gravity = 9.81 # m/s\u00b2 (Earth) initial_height = 0 # m (ground level launch) plot_range_vs_angle(initial_velocities, gravity, initial_height)","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_3","text":"import numpy as np import matplotlib.pyplot as plt # Function to simulate projectile motion def projectile_motion(v0, angle_deg, g=9.81, h0=0): angle_rad = np.radians(angle_deg) v0x = v0 * np.cos(angle_rad) v0y = v0 * np.sin(angle_rad) # Time of flight if h0 == 0: t_flight = 2 * v0y / g else: t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g t = np.linspace(0, t_flight, num=300) x = v0x * t y = h0 + v0y * t - 0.5 * g * t**2 return x, y # Plot setup g = 9.81 h0 = 0 fig, axs = plt.subplots(2, 1, figsize=(10, 12)) # (a) Fixed angle, changing speeds velocities = [30, 40, 50] angle_fixed = 45 colors = ['r', 'purple', 'green'] for v0, color in zip(velocities, colors): x, y = projectile_motion(v0, angle_fixed, g, h0) axs[0].plot(x, y, color=color, label=f'v\u2080 = {v0} m/s') axs[0].set_title('(a) Constant Angle (45\u00b0), Varying Speeds') axs[0].set_xlabel('x (meters)') axs[0].set_ylabel('y (meters)') axs[0].legend() axs[0].grid(True) axs[0].axis('equal') # (b) Fixed speed, changing angles v0_fixed = 50 angles = [15, 45, 75] for angle, color in zip(angles, colors): x, y = projectile_motion(v0_fixed, angle, g, h0) axs[1].plot(x, y, color=color, label=f'\u03b8 = {angle}\u00b0') axs[1].set_title('(b) Constant Speed (50 m/s), Varying Angles') axs[1].set_xlabel('x (meters)') axs[1].set_ylabel('y (meters)') axs[1].legend() axs[1].grid(True) axs[1].axis('equal') plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation The forced damped pendulum is governed by a second-order nonlinear ordinary differential equation (ODE) that models the angular displacement of a pendulum subjected to both damping and an external periodic force. \ud83d\udccc Governing Differential Equation The general equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] Where: \\(\\theta(t)\\) : Angular displacement as a function of time \\(b\\) : Damping coefficient \\(g\\) : Acceleration due to gravity \\(L\\) : Length of the pendulum \\(A\\) : Amplitude of the external driving force \\(\\omega\\) : Angular frequency of the driving force he driving force \ud83d\udd0d Small-Angle Approximation Under the small-angle approximation (where \\(\\theta \\ll 1\\) ), we can linearize the sine function as follows: \\[\\sin\\theta \\approx \\theta\\] This simplification reduces the governing equation to a linear inhomogeneous ordinary differential equation (ODE) : \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t)\\] \ud83d\udcd0 Analytical Solution for Small Angles The general solution to the linearized ODE consists of two parts: Homogeneous solution (related to natural damping): \\( \\(\\theta_h(t)=C_1e^{r_1t}+C_2e^{r_2t}\\) \\) where \\(r_1,r_2\\) are roots of the characteristic equation: \\( \\(r^2+br+\\frac{g}{L}=0\\) \\) Particular solution (related to the external forcing): We assume a steady-state solution of the form: \\[\\theta_p(t)=B\\cos(\\omega t-\\delta)\\] where: The amplitude of the forced oscillation is denoted by \\(B\\) , and the phase lag due to damping is denoted by \\(\\delta\\) . The amplitude of the steady-state response is given by: \\[B=\\frac{A}{\\sqrt{\\left(\\frac{g}{L}-\\omega^2\\right)^2+(b\\omega)^2}}\\] \ud83c\udfaf Resonance Condition Resonance occurs when the driving frequency \\(\\omega\\) approaches the natural frequency of the system: \\[ \\omega_0=\\sqrt{\\frac{g}{L}} \\] At resonance, the system absorbs energy most efficiently from the external force, and the amplitude \\(B\\) reaches a maximum: Without damping ( \\(b=0\\) ): \\[ B\\to\\infty\\quad\\text{as}\\quad\\omega\\to\\omega_0 \\] With damping: \\[ B_{\\text{max}}=\\frac{A}{b\\omega_0} \\] This finite maximum occurs at a slightly shifted resonance frequency: \\[ \\omega_{\\text{res}}=\\sqrt{\\omega_0^2-\\frac{b^2}{2}} \\] \u26a1 Energy Behavior at Resonance The total mechanical energy of the pendulum is the sum of kinetic and potential energy: \\[ E(t) = \\frac{1}{2} m L^2 \\left(\\frac{d\\theta}{dt}\\right)^2 + mgL(1 - \\cos\\theta) \\] Under resonance: The system continually absorbs energy from the external force. The kinetic energy grows in the undamped case. In the damped case, energy input is balanced by dissipation: Leads to a steady-state oscillation. The energy oscillates but remains bounded. \u2705 Summary The equation of motion combines restoring, damping, and external driving forces. Linearization using \\(\\sin\\theta \\approx \\theta\\) simplifies the analysis for small oscillations. Resonance amplifies oscillation amplitudes and affects energy flow. Damping ensures bounded energy growth even at resonance. Investigating the Dynamics of a Forced Damped Pendulum 2. Analysis of Dynamics In this section, we will investigate how the dynamics of the forced damped pendulum are influenced by key parameters such as the damping coefficient \\(b\\) , driving amplitude \\(A\\) , and driving frequency \\(\\omega\\) . Additionally, we will explore the transition between regular motion and chaotic behavior , and interpret the physical meaning of these transitions. \ud83d\udcca Effect of Damping Coefficient \\(b\\) The damping coefficient \\(b\\) plays a crucial role in determining the behavior of the system: For low damping ( \\(b \\to 0\\) ), the pendulum oscillates with large amplitudes, and the system is primarily influenced by the restoring force and external periodic force. For high damping ( \\(b \\to \\infty\\) ), the pendulum quickly returns to rest, and the oscillations decay exponentially. Mathematically, the solution to the damped harmonic oscillator can be written as: \\[\\theta(t) = \\theta_0 e^{-\\gamma t} \\cos(\\omega_0 t + \\delta)\\] Where: \\(\\gamma = \\frac{b}{2m}\\) is the damping coefficient. The damped frequency of oscillation is: \\[\\omega_d = \\sqrt{\\omega_0^2 - \\gamma^2}\\] The amplitude of the oscillations decays as \\(e^{-\\gamma t}\\) , and for high damping, this decay leads to the cessation of motion. \ud83d\udccf Effect of Driving Amplitude \\(A\\) The driving amplitude \\(A\\) determines how much external force is applied to the system: For small \\(A\\) , the system behaves similarly to an undriven damped pendulum, with oscillations decaying over time. For large \\(A\\) , the system enters a regime where the amplitude of oscillations can grow, especially if resonance occurs. The steady-state amplitude of the pendulum's oscillations due to external forcing is given by: \\[B = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + (b\\omega)^2}}\\] As \\(A\\) increases, the system becomes more sensitive to changes in driving frequency \\(\\omega\\) , particularly near resonance. \u2699\ufe0f Effect of Driving Frequency \\(\\omega\\) The driving frequency \\(\\omega\\) determines how quickly the external force oscillates: For \\(\\omega\\) close to \\(\\omega_0\\) (resonance) , the system absorbs energy most efficiently, leading to large oscillations. For \\(\\omega\\) far from \\(\\omega_0\\) , the system experiences weaker driving forces and smaller oscillations. The resonance condition is given by: \\[\\omega_{\\text{res}} = \\sqrt{\\omega_0^2 - \\frac{b^2}{2}}\\] \ud83d\udd04 Transition Between Regular and Chaotic Motion As we vary the damping coefficient \\(b\\) , driving amplitude \\(A\\) , and driving frequency \\(\\omega\\) , the system can exhibit different types of motion: Regular Motion : For certain values of \\(A\\) and \\(\\omega\\) , the pendulum exhibits periodic, stable oscillations. This occurs especially at resonance, where the system synchronizes with the external force. Stable periodic motion can be described by a sinusoidal function: \\( \\(\\theta(t)=B\\cos(\\omega t-\\delta)\\) \\) Chaotic Motion : As \\(A\\) increases or \\(\\omega\\) deviates from resonance, the system can enter a chaotic regime , where the motion becomes irregular and sensitive to initial conditions. Chaotic systems exhibit sensitive dependence on initial conditions, meaning that even tiny differences in initial angles or velocities can lead to vastly different behaviors over time. Lyapunov exponents measure the rate of divergence of nearby trajectories in phase space. Positive Lyapunov exponents are often used to identify chaos. \ud83d\udcd0 Phase Diagrams and Poincar\u00e9 Sections To identify transitions between regular and chaotic motion, we use: Phase Diagrams : A plot of \\(\\theta\\) vs. \\(\\frac{d\\theta}{dt}\\) , which allows us to visualize the state of the system at any point in time. Poincar\u00e9 Sections : A method used to visualize the periodic or chaotic nature of the system by sampling the state of the system at periodic intervals. The transition to chaos can be observed in a bifurcation diagram , which plots the long-term behavior of the system as a function of \\(A\\) or \\(\\omega\\) . \u26a1 Physical Interpretation of Transitions Regular motion is characterized by stable periodic oscillations, where the system's energy input and dissipation are balanced. This type of motion is often seen near resonance. Chaotic motion occurs when the system's sensitivity to initial conditions becomes dominant, and small changes in \\(A\\) , \\(\\omega\\) , or initial conditions lead to unpredictable motion. This is often observed as the system\u2019s energy becomes irregularly distributed. The damping coefficient \\(b\\) determines the rate at which energy is dissipated. As \\(b\\) increases, the system is less likely to exhibit chaos, and more likely to settle into regular motion. \u2705 Summary Damping coefficient \\(b\\) influences the rate at which the system loses energy, with higher values leading to faster dissipation and lower oscillation amplitudes. Driving amplitude \\(A\\) controls the magnitude of the external force, affecting how large the oscillations can grow, especially near resonance. Driving frequency \\(\\omega\\) determines how well the system resonates with the external force, with chaos emerging as the system becomes more sensitive to variations in \\(\\omega\\) . Transitions between regular and chaotic motion depend on the interplay of these parameters. As we approach or move away from resonance, we observe different types of periodic or chaotic behavior. Investigating the Dynamics of a Forced Damped Pendulum 3. Practical Applications The dynamics of the forced damped pendulum, as studied in previous sections, can be applied to a variety of real-world systems. These systems often exhibit similar behavior, such as oscillations, damping, and the effect of external driving forces. In this section, we will explore several practical applications of the forced damped pendulum model in different fields, including energy harvesting , suspension bridges , and oscillating electronic circuits . \ud83c\udf0d Real-World Systems with Similar Dynamics Several real-world systems exhibit dynamics that closely resemble the behavior of a forced damped pendulum. These systems experience forces that cause oscillations, and the interaction of damping forces and external periodic forces results in complex behavior. Some examples include: Mechanical Systems : Mechanical oscillators, such as mass-spring systems, often demonstrate forced oscillations with damping, similar to the pendulum system. Biological Systems : Systems like human gait or the motion of the heart can be modeled using forced damped oscillators to understand rhythmic movements. Electrical Systems : Driven RLC circuits, where an external alternating current (AC) force drives the circuit, exhibit similar dynamics to the forced damped pendulum. \ud83d\udd0b Energy Harvesting Energy harvesting is the process of capturing and storing energy from environmental sources, such as vibrations, thermal gradients, or electromagnetic radiation. A common example of energy harvesting involves the use of vibrational energy harvesters , which convert mechanical vibrations into electrical energy. The forced damped pendulum model is particularly useful in designing these energy harvesters because: The driving force in an energy harvester comes from ambient vibrations, which are external periodic forces that drive oscillations in the system. The damping represents the energy dissipation due to friction or resistance in the harvester\u2019s mechanical components. The resonance condition plays a key role in maximizing the energy extraction. When the frequency of ambient vibrations matches the natural frequency of the harvester, the system oscillates with maximum amplitude, allowing for the most efficient conversion of mechanical energy into electrical energy. The power extracted from the system can be modeled as: \\[ P = \\frac{1}{2} m L^2 \\left(\\frac{d\\theta}{dt}\\right)^2 \\] Where: \\(P\\) is the power extracted from the system. \\(m\\) is the mass of the pendulum. \\(L\\) is the length of the pendulum. \\(\\theta(t)\\) is the angular displacement as a function of time. \ud83c\udf09 Suspension Bridges Suspension bridges are large, flexible structures that are susceptible to oscillations due to external forces, such as wind or traffic loads. The dynamics of the forced damped pendulum model can be applied to understand the oscillations of suspension bridges, particularly when considering: External driving forces , such as wind gusts or traffic-induced vibrations, that act as periodic forces on the bridge. Damping from the bridge\u2019s material properties, as well as from the air resistance and other frictional forces that act on the structure. Resonance between the natural frequency of the bridge and the driving frequency (e.g., wind), which can lead to large oscillations if not properly managed. In suspension bridges, resonance can be dangerous, as it can lead to large-amplitude oscillations, potentially causing structural failure. The Tacoma Narrows Bridge collapse in 1940 is a famous example of resonance-induced failure. The bridge\u2019s motion can be modeled by: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = F_{\\text{ext}}(t) \\] Where: \\(\\theta(t)\\) is the angular displacement of the bridge. \\(F_{\\text{ext}}(t)\\) is the external periodic driving force (e.g., wind). \\(b\\) is the damping coefficient related to the air resistance and friction. By controlling the damping coefficient and avoiding resonance, engineers can reduce the risk of catastrophic failure in suspension bridges. \ud83d\udca1 Oscillating Electronic Circuits In electronics, RLC circuits (Resistor, Inductor, Capacitor) are commonly used to model oscillations in driven systems. A forced damped pendulum can be applied to analyze these circuits, as they exhibit similar dynamics: Driving Force : In an RLC circuit, the external driving force is the alternating current (AC) voltage that drives the system. Damping : Damping in RLC circuits is represented by the resistance \\(R\\) , which dissipates energy. Resonance : Just like in the pendulum, the circuit exhibits resonance when the driving frequency matches the natural frequency of the LC circuit. The behavior of an RLC circuit under external driving forces can be described by the following equation: \\[ L \\frac{d^2 q}{dt^2} + R \\frac{dq}{dt} + \\frac{1}{C} q = V_{\\text{ext}}(t) \\] Where: \\(q(t)\\) is the charge on the capacitor. \\(V_{\\text{ext}}(t)\\) is the external driving voltage. \\(L\\) is the inductance of the coil. \\(C\\) is the capacitance of the capacitor. \\(R\\) is the resistance of the circuit. At resonance, the current in the circuit can become very large, leading to potential damage if not properly controlled. The forced damped pendulum model can be used to predict and mitigate these effects by adjusting the driving frequency and damping characteristics. \u2705 Summary Energy Harvesting : The forced damped pendulum model helps design efficient vibrational energy harvesters by maximizing energy extraction at resonance. Suspension Bridges : Understanding resonance and damping in suspension bridges can prevent large amplitude oscillations and avoid structural failure due to external driving forces like wind. Oscillating Electronic Circuits : The model can also be applied to RLC circuits, where external AC voltages drive oscillations, and resonance must be carefully controlled to avoid damage. In all these systems, the principles of forced oscillations, damping, and resonance play critical roles in ensuring proper functionality and avoiding failure. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Common parameters g = 9.81 # gravitational acceleration (m/s\u00b2) L = 1.0 # pendulum length (m) theta0 = 0.2 # small initial angle (radians) omega0 = 0.0 # initial angular velocity (rad/s) y0 = [theta0, omega0] t_span = (0, 20) t_eval = np.linspace(t_span[0], t_span[1], 1000) # 1) Simple Pendulum (b = 0, A = 0) def simple_pendulum(t, y): theta, omega = y dydt = [omega, -(g / L) * np.sin(theta)] return dydt sol_simple = solve_ivp(simple_pendulum, t_span, y0, t_eval=t_eval) # 2) Damped Pendulum (b != 0, A = 0) b = 0.2 # damping coefficient def damped_pendulum(t, y): theta, omega = y dydt = [omega, -b * omega - (g / L) * np.sin(theta)] return dydt sol_damped = solve_ivp(damped_pendulum, t_span, y0, t_eval=t_eval) # 3) Forced Pendulum (b = 0, A != 0) A = 0.5 # driving force amplitude omega_drive = 2/3 # driving frequency def forced_pendulum(t, y): theta, omega = y dydt = [omega, -(g / L) * np.sin(theta) + A * np.cos(omega_drive * t)] return dydt sol_forced = solve_ivp(forced_pendulum, t_span, y0, t_eval=t_eval) # Function to plot one pendulum case (time series + phase portrait) def plot_case(sol, case_title, color): theta = sol.y[0] omega = sol.y[1] t = sol.t fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4)) # Time series ax1.plot(t, theta, color=color, linewidth=1) ax1.set_xlabel('Time (s)') ax1.set_ylabel('Theta (rad)') ax1.set_title('Time Series') ax1.grid(True) # Phase portrait ax2.plot(theta, omega, color=color, linewidth=1) ax2.set_xlabel('Theta (rad)') ax2.set_ylabel('Omega (rad/s)') ax2.set_title('Phase Portrait') ax2.grid(True) # Main title fig.suptitle(case_title, fontsize=16, color=color) plt.tight_layout() plt.subplots_adjust(top=0.8) # Adjust to fit main title plt.show() # --- Now plot each system separately --- plot_case(sol_simple, \"1) Simple Pendulum\", 'red') plot_case(sol_damped, \"2) Damped Pendulum\", 'blue') plot_case(sol_forced, \"3) Forced Pendulum\", 'teal') import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Common parameters g = 9.81 # gravitational acceleration (m/s\u00b2) L = 1.0 # pendulum length (m) theta0 = 0.2 # initial angle (radians) omega0 = 0.0 # initial angular velocity (rad/s) y0 = [theta0, omega0] t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 2000) # Function to define forced, damped pendulum def forced_damped_pendulum(t, y, b, A, omega_drive): theta, omega = y dydt = [omega, -b * omega - (g / L) * np.sin(theta) + A * np.cos(omega_drive * t)] return dydt # Scenario 1: Mild damping, moderate forcing b1 = 0.1 A1 = 0.5 omega_drive1 = 2/3 sol1 = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b1, A1, omega_drive1)) # Scenario 2: Stronger damping, stronger forcing b2 = 0.5 A2 = 1.2 omega_drive2 = 2/3 sol2 = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b2, A2, omega_drive2)) # Plotting function def plot_forced_damped(sol, title, color): theta = sol.y[0] omega = sol.y[1] t = sol.t fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5)) # Time series ax1.plot(t, theta, color=color, linewidth=1) ax1.set_xlabel('Time (s)') ax1.set_ylabel('Theta (rad)') ax1.set_title('Time Series') ax1.grid(True) # Phase portrait ax2.plot(theta, omega, color=color, linewidth=1) ax2.set_xlabel('Theta (rad)') ax2.set_ylabel('Omega (rad/s)') ax2.set_title('Phase Portrait') ax2.grid(True) fig.suptitle(title, fontsize=16, color=color) plt.tight_layout() plt.subplots_adjust(top=0.85) plt.show() # Plot both scenarios plot_forced_damped(sol1, \"Scenario 1: Mild Damping, Moderate Forcing\", 'purple') plot_forced_damped(sol2, \"Scenario 2: Strong Damping, Strong Forcing\", 'darkorange') import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equations def forced_damped_pendulum(t, y, gamma, omega0, A, omega): theta, omega_t = y dtheta_dt = omega_t domega_dt = -gamma * omega_t - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.0 # Natural frequency A = 1.2 # Forcing amplitude omega = 2.0 # Forcing frequency # Initial conditions and time span t_span = (0, 50) y0 = [0.2, 0] # Initial angle and angular velocity t_eval = np.linspace(0, 50, 1000) # Solve the ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(gamma, omega0, A, omega)) # Plot results plt.figure(figsize=(10,5)) plt.plot(sol.t, sol.y[0], label=\"Theta (angle)\") plt.xlabel(\"Time\") plt.ylabel(\"Angle (radians)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show() plt.figure(figsize=(8, 4)) sol = solve_ivp(damped_pendulum, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=\"Damped Pendulum\", color='orange') plt.title(\"2. Damped Pendulum\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() plt.figure(figsize=(8, 4)) sol = solve_ivp(forced_pendulum, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=\"Forced Pendulum\", color='green') plt.title(\"3. Forced Pendulum\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() plt.figure(figsize=(8, 4)) sol = solve_ivp(forced_damped_1, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=\"Forced Damped - Scenario 1\", color='red') plt.title(\"4. Forced Damped Pendulum - Scenario 1\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() plt.figure(figsize=(8, 4)) sol = solve_ivp(forced_damped_2, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=\"Forced Damped - Scenario 2\", color='purple') plt.title(\"5. Forced Damped Pendulum - Scenario 2\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Common parameters g = 9.81 l = 1.0 gamma = 0.1 A1 = 0.5 A2 = 1.2 w1 = 2.0 w2 = 3.5 t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) theta0 = [np.pi / 4, 0] # initial [theta, omega] # Phase plot function def phase_plot(system_func, title): sol = solve_ivp(system_func, t_span, theta0, t_eval=t_eval) theta = sol.y[0] omega = sol.y[1] plt.figure(figsize=(6, 5)) plt.plot(theta, omega, label=title) plt.title(title + \" - Phase Diagram\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular Velocity \u03c9 (rad/s)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() # 1. Simple Pendulum def simple_pendulum(t, y): return [y[1], - (g / l) * np.sin(y[0])] phase_plot(simple_pendulum, \"1. Simple Pendulum\") # 2. Damped Pendulum def damped_pendulum(t, y): return [y[1], -gamma * y[1] - (g / l) * np.sin(y[0])] phase_plot(damped_pendulum, \"2. Damped Pendulum\") # 3. Forced Pendulum def forced_pendulum(t, y): return [y[1], - (g / l) * np.sin(y[0]) + A1 * np.cos(w1 * t)] phase_plot(forced_pendulum, \"3. Forced Pendulum\") # 4. Forced Damped Pendulum - Scenario 1 def forced_damped_1(t, y): return [y[1], -gamma * y[1] - (g / l) * np.sin(y[0]) + A1 * np.cos(w1 * t)] phase_plot(forced_damped_1, \"4. Forced Damped - Scenario 1\") # 5. Forced Damped Pendulum - Scenario 2 def forced_damped_2(t, y): return [y[1], -0.05 * y[1] - (g / l) * np.sin(y[0]) + A2 * np.cos(w2 * t)] phase_plot(forced_damped_2, \"5. Forced Damped - Scenario 2\")","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The forced damped pendulum is governed by a second-order nonlinear ordinary differential equation (ODE) that models the angular displacement of a pendulum subjected to both damping and an external periodic force.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-differential-equation","text":"The general equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] Where: \\(\\theta(t)\\) : Angular displacement as a function of time \\(b\\) : Damping coefficient \\(g\\) : Acceleration due to gravity \\(L\\) : Length of the pendulum \\(A\\) : Amplitude of the external driving force \\(\\omega\\) : Angular frequency of the driving force he driving force","title":"\ud83d\udccc Governing Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"Under the small-angle approximation (where \\(\\theta \\ll 1\\) ), we can linearize the sine function as follows: \\[\\sin\\theta \\approx \\theta\\] This simplification reduces the governing equation to a linear inhomogeneous ordinary differential equation (ODE) : \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t)\\]","title":"\ud83d\udd0d Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analytical-solution-for-small-angles","text":"The general solution to the linearized ODE consists of two parts: Homogeneous solution (related to natural damping): \\( \\(\\theta_h(t)=C_1e^{r_1t}+C_2e^{r_2t}\\) \\) where \\(r_1,r_2\\) are roots of the characteristic equation: \\( \\(r^2+br+\\frac{g}{L}=0\\) \\) Particular solution (related to the external forcing): We assume a steady-state solution of the form: \\[\\theta_p(t)=B\\cos(\\omega t-\\delta)\\] where: The amplitude of the forced oscillation is denoted by \\(B\\) , and the phase lag due to damping is denoted by \\(\\delta\\) . The amplitude of the steady-state response is given by: \\[B=\\frac{A}{\\sqrt{\\left(\\frac{g}{L}-\\omega^2\\right)^2+(b\\omega)^2}}\\]","title":"\ud83d\udcd0 Analytical Solution for Small Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Resonance occurs when the driving frequency \\(\\omega\\) approaches the natural frequency of the system: \\[ \\omega_0=\\sqrt{\\frac{g}{L}} \\] At resonance, the system absorbs energy most efficiently from the external force, and the amplitude \\(B\\) reaches a maximum: Without damping ( \\(b=0\\) ): \\[ B\\to\\infty\\quad\\text{as}\\quad\\omega\\to\\omega_0 \\] With damping: \\[ B_{\\text{max}}=\\frac{A}{b\\omega_0} \\] This finite maximum occurs at a slightly shifted resonance frequency: \\[ \\omega_{\\text{res}}=\\sqrt{\\omega_0^2-\\frac{b^2}{2}} \\]","title":"\ud83c\udfaf Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-behavior-at-resonance","text":"The total mechanical energy of the pendulum is the sum of kinetic and potential energy: \\[ E(t) = \\frac{1}{2} m L^2 \\left(\\frac{d\\theta}{dt}\\right)^2 + mgL(1 - \\cos\\theta) \\] Under resonance: The system continually absorbs energy from the external force. The kinetic energy grows in the undamped case. In the damped case, energy input is balanced by dissipation: Leads to a steady-state oscillation. The energy oscillates but remains bounded.","title":"\u26a1 Energy Behavior at Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary","text":"The equation of motion combines restoring, damping, and external driving forces. Linearization using \\(\\sin\\theta \\approx \\theta\\) simplifies the analysis for small oscillations. Resonance amplifies oscillation amplitudes and affects energy flow. Damping ensures bounded energy growth even at resonance.","title":"\u2705 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum_1","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"In this section, we will investigate how the dynamics of the forced damped pendulum are influenced by key parameters such as the damping coefficient \\(b\\) , driving amplitude \\(A\\) , and driving frequency \\(\\omega\\) . Additionally, we will explore the transition between regular motion and chaotic behavior , and interpret the physical meaning of these transitions.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-damping-coefficient-b","text":"The damping coefficient \\(b\\) plays a crucial role in determining the behavior of the system: For low damping ( \\(b \\to 0\\) ), the pendulum oscillates with large amplitudes, and the system is primarily influenced by the restoring force and external periodic force. For high damping ( \\(b \\to \\infty\\) ), the pendulum quickly returns to rest, and the oscillations decay exponentially. Mathematically, the solution to the damped harmonic oscillator can be written as: \\[\\theta(t) = \\theta_0 e^{-\\gamma t} \\cos(\\omega_0 t + \\delta)\\] Where: \\(\\gamma = \\frac{b}{2m}\\) is the damping coefficient. The damped frequency of oscillation is: \\[\\omega_d = \\sqrt{\\omega_0^2 - \\gamma^2}\\] The amplitude of the oscillations decays as \\(e^{-\\gamma t}\\) , and for high damping, this decay leads to the cessation of motion.","title":"\ud83d\udcca Effect of Damping Coefficient \\(b\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-driving-amplitude-a","text":"The driving amplitude \\(A\\) determines how much external force is applied to the system: For small \\(A\\) , the system behaves similarly to an undriven damped pendulum, with oscillations decaying over time. For large \\(A\\) , the system enters a regime where the amplitude of oscillations can grow, especially if resonance occurs. The steady-state amplitude of the pendulum's oscillations due to external forcing is given by: \\[B = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + (b\\omega)^2}}\\] As \\(A\\) increases, the system becomes more sensitive to changes in driving frequency \\(\\omega\\) , particularly near resonance.","title":"\ud83d\udccf Effect of Driving Amplitude \\(A\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-driving-frequency-omega","text":"The driving frequency \\(\\omega\\) determines how quickly the external force oscillates: For \\(\\omega\\) close to \\(\\omega_0\\) (resonance) , the system absorbs energy most efficiently, leading to large oscillations. For \\(\\omega\\) far from \\(\\omega_0\\) , the system experiences weaker driving forces and smaller oscillations. The resonance condition is given by: \\[\\omega_{\\text{res}} = \\sqrt{\\omega_0^2 - \\frac{b^2}{2}}\\]","title":"\u2699\ufe0f Effect of Driving Frequency \\(\\omega\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-between-regular-and-chaotic-motion","text":"As we vary the damping coefficient \\(b\\) , driving amplitude \\(A\\) , and driving frequency \\(\\omega\\) , the system can exhibit different types of motion: Regular Motion : For certain values of \\(A\\) and \\(\\omega\\) , the pendulum exhibits periodic, stable oscillations. This occurs especially at resonance, where the system synchronizes with the external force. Stable periodic motion can be described by a sinusoidal function: \\( \\(\\theta(t)=B\\cos(\\omega t-\\delta)\\) \\) Chaotic Motion : As \\(A\\) increases or \\(\\omega\\) deviates from resonance, the system can enter a chaotic regime , where the motion becomes irregular and sensitive to initial conditions. Chaotic systems exhibit sensitive dependence on initial conditions, meaning that even tiny differences in initial angles or velocities can lead to vastly different behaviors over time. Lyapunov exponents measure the rate of divergence of nearby trajectories in phase space. Positive Lyapunov exponents are often used to identify chaos.","title":"\ud83d\udd04 Transition Between Regular and Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-diagrams-and-poincare-sections","text":"To identify transitions between regular and chaotic motion, we use: Phase Diagrams : A plot of \\(\\theta\\) vs. \\(\\frac{d\\theta}{dt}\\) , which allows us to visualize the state of the system at any point in time. Poincar\u00e9 Sections : A method used to visualize the periodic or chaotic nature of the system by sampling the state of the system at periodic intervals. The transition to chaos can be observed in a bifurcation diagram , which plots the long-term behavior of the system as a function of \\(A\\) or \\(\\omega\\) .","title":"\ud83d\udcd0 Phase Diagrams and Poincar\u00e9 Sections"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#physical-interpretation-of-transitions","text":"Regular motion is characterized by stable periodic oscillations, where the system's energy input and dissipation are balanced. This type of motion is often seen near resonance. Chaotic motion occurs when the system's sensitivity to initial conditions becomes dominant, and small changes in \\(A\\) , \\(\\omega\\) , or initial conditions lead to unpredictable motion. This is often observed as the system\u2019s energy becomes irregularly distributed. The damping coefficient \\(b\\) determines the rate at which energy is dissipated. As \\(b\\) increases, the system is less likely to exhibit chaos, and more likely to settle into regular motion.","title":"\u26a1 Physical Interpretation of Transitions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary_1","text":"Damping coefficient \\(b\\) influences the rate at which the system loses energy, with higher values leading to faster dissipation and lower oscillation amplitudes. Driving amplitude \\(A\\) controls the magnitude of the external force, affecting how large the oscillations can grow, especially near resonance. Driving frequency \\(\\omega\\) determines how well the system resonates with the external force, with chaos emerging as the system becomes more sensitive to variations in \\(\\omega\\) . Transitions between regular and chaotic motion depend on the interplay of these parameters. As we approach or move away from resonance, we observe different types of periodic or chaotic behavior.","title":"\u2705 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum_2","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The dynamics of the forced damped pendulum, as studied in previous sections, can be applied to a variety of real-world systems. These systems often exhibit similar behavior, such as oscillations, damping, and the effect of external driving forces. In this section, we will explore several practical applications of the forced damped pendulum model in different fields, including energy harvesting , suspension bridges , and oscillating electronic circuits .","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#real-world-systems-with-similar-dynamics","text":"Several real-world systems exhibit dynamics that closely resemble the behavior of a forced damped pendulum. These systems experience forces that cause oscillations, and the interaction of damping forces and external periodic forces results in complex behavior. Some examples include: Mechanical Systems : Mechanical oscillators, such as mass-spring systems, often demonstrate forced oscillations with damping, similar to the pendulum system. Biological Systems : Systems like human gait or the motion of the heart can be modeled using forced damped oscillators to understand rhythmic movements. Electrical Systems : Driven RLC circuits, where an external alternating current (AC) force drives the circuit, exhibit similar dynamics to the forced damped pendulum.","title":"\ud83c\udf0d Real-World Systems with Similar Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-harvesting","text":"Energy harvesting is the process of capturing and storing energy from environmental sources, such as vibrations, thermal gradients, or electromagnetic radiation. A common example of energy harvesting involves the use of vibrational energy harvesters , which convert mechanical vibrations into electrical energy. The forced damped pendulum model is particularly useful in designing these energy harvesters because: The driving force in an energy harvester comes from ambient vibrations, which are external periodic forces that drive oscillations in the system. The damping represents the energy dissipation due to friction or resistance in the harvester\u2019s mechanical components. The resonance condition plays a key role in maximizing the energy extraction. When the frequency of ambient vibrations matches the natural frequency of the harvester, the system oscillates with maximum amplitude, allowing for the most efficient conversion of mechanical energy into electrical energy. The power extracted from the system can be modeled as: \\[ P = \\frac{1}{2} m L^2 \\left(\\frac{d\\theta}{dt}\\right)^2 \\] Where: \\(P\\) is the power extracted from the system. \\(m\\) is the mass of the pendulum. \\(L\\) is the length of the pendulum. \\(\\theta(t)\\) is the angular displacement as a function of time.","title":"\ud83d\udd0b Energy Harvesting"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#suspension-bridges","text":"Suspension bridges are large, flexible structures that are susceptible to oscillations due to external forces, such as wind or traffic loads. The dynamics of the forced damped pendulum model can be applied to understand the oscillations of suspension bridges, particularly when considering: External driving forces , such as wind gusts or traffic-induced vibrations, that act as periodic forces on the bridge. Damping from the bridge\u2019s material properties, as well as from the air resistance and other frictional forces that act on the structure. Resonance between the natural frequency of the bridge and the driving frequency (e.g., wind), which can lead to large oscillations if not properly managed. In suspension bridges, resonance can be dangerous, as it can lead to large-amplitude oscillations, potentially causing structural failure. The Tacoma Narrows Bridge collapse in 1940 is a famous example of resonance-induced failure. The bridge\u2019s motion can be modeled by: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = F_{\\text{ext}}(t) \\] Where: \\(\\theta(t)\\) is the angular displacement of the bridge. \\(F_{\\text{ext}}(t)\\) is the external periodic driving force (e.g., wind). \\(b\\) is the damping coefficient related to the air resistance and friction. By controlling the damping coefficient and avoiding resonance, engineers can reduce the risk of catastrophic failure in suspension bridges.","title":"\ud83c\udf09 Suspension Bridges"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#oscillating-electronic-circuits","text":"In electronics, RLC circuits (Resistor, Inductor, Capacitor) are commonly used to model oscillations in driven systems. A forced damped pendulum can be applied to analyze these circuits, as they exhibit similar dynamics: Driving Force : In an RLC circuit, the external driving force is the alternating current (AC) voltage that drives the system. Damping : Damping in RLC circuits is represented by the resistance \\(R\\) , which dissipates energy. Resonance : Just like in the pendulum, the circuit exhibits resonance when the driving frequency matches the natural frequency of the LC circuit. The behavior of an RLC circuit under external driving forces can be described by the following equation: \\[ L \\frac{d^2 q}{dt^2} + R \\frac{dq}{dt} + \\frac{1}{C} q = V_{\\text{ext}}(t) \\] Where: \\(q(t)\\) is the charge on the capacitor. \\(V_{\\text{ext}}(t)\\) is the external driving voltage. \\(L\\) is the inductance of the coil. \\(C\\) is the capacitance of the capacitor. \\(R\\) is the resistance of the circuit. At resonance, the current in the circuit can become very large, leading to potential damage if not properly controlled. The forced damped pendulum model can be used to predict and mitigate these effects by adjusting the driving frequency and damping characteristics.","title":"\ud83d\udca1 Oscillating Electronic Circuits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary_2","text":"Energy Harvesting : The forced damped pendulum model helps design efficient vibrational energy harvesters by maximizing energy extraction at resonance. Suspension Bridges : Understanding resonance and damping in suspension bridges can prevent large amplitude oscillations and avoid structural failure due to external driving forces like wind. Oscillating Electronic Circuits : The model can also be applied to RLC circuits, where external AC voltages drive oscillations, and resonance must be carefully controlled to avoid damage. In all these systems, the principles of forced oscillations, damping, and resonance play critical roles in ensuring proper functionality and avoiding failure.","title":"\u2705 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Common parameters g = 9.81 # gravitational acceleration (m/s\u00b2) L = 1.0 # pendulum length (m) theta0 = 0.2 # small initial angle (radians) omega0 = 0.0 # initial angular velocity (rad/s) y0 = [theta0, omega0] t_span = (0, 20) t_eval = np.linspace(t_span[0], t_span[1], 1000) # 1) Simple Pendulum (b = 0, A = 0) def simple_pendulum(t, y): theta, omega = y dydt = [omega, -(g / L) * np.sin(theta)] return dydt sol_simple = solve_ivp(simple_pendulum, t_span, y0, t_eval=t_eval) # 2) Damped Pendulum (b != 0, A = 0) b = 0.2 # damping coefficient def damped_pendulum(t, y): theta, omega = y dydt = [omega, -b * omega - (g / L) * np.sin(theta)] return dydt sol_damped = solve_ivp(damped_pendulum, t_span, y0, t_eval=t_eval) # 3) Forced Pendulum (b = 0, A != 0) A = 0.5 # driving force amplitude omega_drive = 2/3 # driving frequency def forced_pendulum(t, y): theta, omega = y dydt = [omega, -(g / L) * np.sin(theta) + A * np.cos(omega_drive * t)] return dydt sol_forced = solve_ivp(forced_pendulum, t_span, y0, t_eval=t_eval) # Function to plot one pendulum case (time series + phase portrait) def plot_case(sol, case_title, color): theta = sol.y[0] omega = sol.y[1] t = sol.t fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4)) # Time series ax1.plot(t, theta, color=color, linewidth=1) ax1.set_xlabel('Time (s)') ax1.set_ylabel('Theta (rad)') ax1.set_title('Time Series') ax1.grid(True) # Phase portrait ax2.plot(theta, omega, color=color, linewidth=1) ax2.set_xlabel('Theta (rad)') ax2.set_ylabel('Omega (rad/s)') ax2.set_title('Phase Portrait') ax2.grid(True) # Main title fig.suptitle(case_title, fontsize=16, color=color) plt.tight_layout() plt.subplots_adjust(top=0.8) # Adjust to fit main title plt.show() # --- Now plot each system separately --- plot_case(sol_simple, \"1) Simple Pendulum\", 'red') plot_case(sol_damped, \"2) Damped Pendulum\", 'blue') plot_case(sol_forced, \"3) Forced Pendulum\", 'teal')","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_2","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Common parameters g = 9.81 # gravitational acceleration (m/s\u00b2) L = 1.0 # pendulum length (m) theta0 = 0.2 # initial angle (radians) omega0 = 0.0 # initial angular velocity (rad/s) y0 = [theta0, omega0] t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 2000) # Function to define forced, damped pendulum def forced_damped_pendulum(t, y, b, A, omega_drive): theta, omega = y dydt = [omega, -b * omega - (g / L) * np.sin(theta) + A * np.cos(omega_drive * t)] return dydt # Scenario 1: Mild damping, moderate forcing b1 = 0.1 A1 = 0.5 omega_drive1 = 2/3 sol1 = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b1, A1, omega_drive1)) # Scenario 2: Stronger damping, stronger forcing b2 = 0.5 A2 = 1.2 omega_drive2 = 2/3 sol2 = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b2, A2, omega_drive2)) # Plotting function def plot_forced_damped(sol, title, color): theta = sol.y[0] omega = sol.y[1] t = sol.t fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5)) # Time series ax1.plot(t, theta, color=color, linewidth=1) ax1.set_xlabel('Time (s)') ax1.set_ylabel('Theta (rad)') ax1.set_title('Time Series') ax1.grid(True) # Phase portrait ax2.plot(theta, omega, color=color, linewidth=1) ax2.set_xlabel('Theta (rad)') ax2.set_ylabel('Omega (rad/s)') ax2.set_title('Phase Portrait') ax2.grid(True) fig.suptitle(title, fontsize=16, color=color) plt.tight_layout() plt.subplots_adjust(top=0.85) plt.show() # Plot both scenarios plot_forced_damped(sol1, \"Scenario 1: Mild Damping, Moderate Forcing\", 'purple') plot_forced_damped(sol2, \"Scenario 2: Strong Damping, Strong Forcing\", 'darkorange')","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_3","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equations def forced_damped_pendulum(t, y, gamma, omega0, A, omega): theta, omega_t = y dtheta_dt = omega_t domega_dt = -gamma * omega_t - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.0 # Natural frequency A = 1.2 # Forcing amplitude omega = 2.0 # Forcing frequency # Initial conditions and time span t_span = (0, 50) y0 = [0.2, 0] # Initial angle and angular velocity t_eval = np.linspace(0, 50, 1000) # Solve the ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(gamma, omega0, A, omega)) # Plot results plt.figure(figsize=(10,5)) plt.plot(sol.t, sol.y[0], label=\"Theta (angle)\") plt.xlabel(\"Time\") plt.ylabel(\"Angle (radians)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_4","text":"plt.figure(figsize=(8, 4)) sol = solve_ivp(damped_pendulum, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=\"Damped Pendulum\", color='orange') plt.title(\"2. Damped Pendulum\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_5","text":"plt.figure(figsize=(8, 4)) sol = solve_ivp(forced_pendulum, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=\"Forced Pendulum\", color='green') plt.title(\"3. Forced Pendulum\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_6","text":"plt.figure(figsize=(8, 4)) sol = solve_ivp(forced_damped_1, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=\"Forced Damped - Scenario 1\", color='red') plt.title(\"4. Forced Damped Pendulum - Scenario 1\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_7","text":"plt.figure(figsize=(8, 4)) sol = solve_ivp(forced_damped_2, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=\"Forced Damped - Scenario 2\", color='purple') plt.title(\"5. Forced Damped Pendulum - Scenario 2\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_8","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Common parameters g = 9.81 l = 1.0 gamma = 0.1 A1 = 0.5 A2 = 1.2 w1 = 2.0 w2 = 3.5 t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) theta0 = [np.pi / 4, 0] # initial [theta, omega] # Phase plot function def phase_plot(system_func, title): sol = solve_ivp(system_func, t_span, theta0, t_eval=t_eval) theta = sol.y[0] omega = sol.y[1] plt.figure(figsize=(6, 5)) plt.plot(theta, omega, label=title) plt.title(title + \" - Phase Diagram\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular Velocity \u03c9 (rad/s)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() # 1. Simple Pendulum def simple_pendulum(t, y): return [y[1], - (g / l) * np.sin(y[0])] phase_plot(simple_pendulum, \"1. Simple Pendulum\") # 2. Damped Pendulum def damped_pendulum(t, y): return [y[1], -gamma * y[1] - (g / l) * np.sin(y[0])] phase_plot(damped_pendulum, \"2. Damped Pendulum\") # 3. Forced Pendulum def forced_pendulum(t, y): return [y[1], - (g / l) * np.sin(y[0]) + A1 * np.cos(w1 * t)] phase_plot(forced_pendulum, \"3. Forced Pendulum\") # 4. Forced Damped Pendulum - Scenario 1 def forced_damped_1(t, y): return [y[1], -gamma * y[1] - (g / l) * np.sin(y[0]) + A1 * np.cos(w1 * t)] phase_plot(forced_damped_1, \"4. Forced Damped - Scenario 1\") # 5. Forced Damped Pendulum - Scenario 2 def forced_damped_2(t, y): return [y[1], -0.05 * y[1] - (g / l) * np.sin(y[0]) + A2 * np.cos(w2 * t)] phase_plot(forced_damped_2, \"5. Forced Damped - Scenario 2\")","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Gravity Problem 1: Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. It connects orbital dynamics to gravitational forces Crucial for: Determining planetary motion Designing satellite trajectories Estimating masses of celestial objects Task Derive the relationship between: Orbital period \\(T\\) Orbital radius \\(r\\) Use Newton's Law of Gravitation and centripetal force Apply the law to real-world cases like: Moon's orbit around Earth Planets in the Solar System Simulate circular orbits to verify the relation Derivation Step 1: Newton's Law of Universal Gravitation \\[F_g = \\frac{GMm}{r^2}\\] Step 2: Centripetal Force Required for Circular Motion \\[F_c = \\frac{mv^2}{r}\\] Equating gravitational force and centripetal force : \\[\\frac{GMm}{r^2} = \\frac{mv^2}{r}\\] Cancel \\(m\\) and rearrange: \\[v^2 = \\frac{GM}{r}\\] Step 3: Express velocity in terms of period \\(T\\) Orbital speed \\(v = \\frac{2\\pi r}{T}\\) Substitute into the equation: \\[\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{GM}{r}\\] Expand and simplify: \\[\\frac{4\\pi^2 r^2}{T^2} = \\frac{GM}{r}\\] Multiply both sides by \\(T^2 r\\) : \\[4\\pi^2 r^3 = GMT^2\\] Finally: \\[T^2 = \\frac{4\\pi^2}{GM} r^3\\] Implications Kepler's Third Law : \\(T^2 \\propto r^3\\) This relation: Helps determine the mass of the central object Predicts motion of satellites and moons Useful for astro-navigation and space missions Real-World Example: The Moon Mass of Earth: \\(M = 5.97 \\times 10^{24}\\) kg Radius of Moon's orbit: \\(r = 3.84 \\times 10^8\\) m Using: \\[T = 2\\pi \\sqrt{\\frac{r^3}{GM}}\\] Python Simulation import numpy as np import matplotlib.pyplot as plt import pandas as pd planets = { 'Mercury': {'r': 57.9e6, 'T': 0.241}, 'Venus': {'r': 108.2e6, 'T': 0.615}, 'Earth': {'r': 149.6e6, 'T': 1.000}, 'Mars': {'r': 227.9e6, 'T': 1.881} } data = { 'Planet': [], 'r (10^6 km)': [], 'T (years)': [], 'r\u00b3 (10^18 km\u00b3)': [], 'T\u00b2 (years\u00b2)': [] } for name, values in planets.items(): r = values['r'] T = values['T'] data['Planet'].append(name) data['r (10^6 km)'].append(r) data['T (years)'].append(T) data['r\u00b3 (10^18 km\u00b3)'].append((r**3) / 1e18) data['T\u00b2 (years\u00b2)'].append(T**2) df = pd.DataFrame(data) print(df) plt.plot(df['r\u00b3 (10^18 km\u00b3)'], df['T\u00b2 (years\u00b2)'], 'ro-', markersize=8) for i, txt in enumerate(df['Planet']): plt.annotate(txt, (df['r\u00b3 (10^18 km\u00b3)'][i], df['T\u00b2 (years\u00b2)'][i]), textcoords=\"offset points\", xytext=(5,5), ha='center') plt.xlabel(r'$r^3$ (in $10^{18}\\ km^3$)') plt.ylabel(r'$T^2$ (in $years^2$)') plt.title('Verification of Kepler\\'s Third Law with Solar System Planets') plt.grid(True) plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Orbital parameters (in astronomical units and years) radius = 1 # Orbital radius in AU period = 1 # Orbital period in years omega = 2 * np.pi / period # Angular velocity (rad/year) # Time array (convert years to days) t = np.linspace(0, period, 360) x = radius * np.cos(omega * t * 365) # X-position over time y = radius * np.sin(omega * t * 365) # Y-position over time # Set up the figure and axis fig, ax = plt.subplots(figsize=(6, 6)) ax.set_aspect('equal') ax.set_xlim(-1.5, 1.5) ax.set_ylim(-1.5, 1.5) ax.set_title(\"Circular Planet Orbit (Kepler's 3rd Law)\") ax.set_xlabel(\"X (AU)\") ax.set_ylabel(\"Y (AU)\") # Draw the Sun and initialize the planet sun = plt.Circle((0, 0), 0.05, color='gold', label='Sun') planet, = plt.plot([], [], 'o', color='blue', label='Planet') orbit, = plt.plot(x, y, linestyle='dotted', color='gray', alpha=0.5) # Add the Sun to the plot ax.add_artist(sun) ax.legend(loc=\"upper right\") # Animation update function def update(frame): # Modified to provide sequences to set_data planet.set_data([x[frame]], [y[frame]]) return planet, # Create animation ani = FuncAnimation(fig, update, frames=len(t), interval=30, blit=True) plt.show()","title":"Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity","text":"","title":"Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"","title":"Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. It connects orbital dynamics to gravitational forces Crucial for: Determining planetary motion Designing satellite trajectories Estimating masses of celestial objects","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task","text":"Derive the relationship between: Orbital period \\(T\\) Orbital radius \\(r\\) Use Newton's Law of Gravitation and centripetal force Apply the law to real-world cases like: Moon's orbit around Earth Planets in the Solar System Simulate circular orbits to verify the relation","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation","text":"Step 1: Newton's Law of Universal Gravitation \\[F_g = \\frac{GMm}{r^2}\\] Step 2: Centripetal Force Required for Circular Motion \\[F_c = \\frac{mv^2}{r}\\] Equating gravitational force and centripetal force : \\[\\frac{GMm}{r^2} = \\frac{mv^2}{r}\\] Cancel \\(m\\) and rearrange: \\[v^2 = \\frac{GM}{r}\\] Step 3: Express velocity in terms of period \\(T\\) Orbital speed \\(v = \\frac{2\\pi r}{T}\\) Substitute into the equation: \\[\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{GM}{r}\\] Expand and simplify: \\[\\frac{4\\pi^2 r^2}{T^2} = \\frac{GM}{r}\\] Multiply both sides by \\(T^2 r\\) : \\[4\\pi^2 r^3 = GMT^2\\] Finally: \\[T^2 = \\frac{4\\pi^2}{GM} r^3\\]","title":"Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications","text":"Kepler's Third Law : \\(T^2 \\propto r^3\\) This relation: Helps determine the mass of the central object Predicts motion of satellites and moons Useful for astro-navigation and space missions","title":"Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-example-the-moon","text":"Mass of Earth: \\(M = 5.97 \\times 10^{24}\\) kg Radius of Moon's orbit: \\(r = 3.84 \\times 10^8\\) m Using: \\[T = 2\\pi \\sqrt{\\frac{r^3}{GM}}\\]","title":"Real-World Example: The Moon"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation","text":"","title":"Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_2","text":"import numpy as np import matplotlib.pyplot as plt import pandas as pd planets = { 'Mercury': {'r': 57.9e6, 'T': 0.241}, 'Venus': {'r': 108.2e6, 'T': 0.615}, 'Earth': {'r': 149.6e6, 'T': 1.000}, 'Mars': {'r': 227.9e6, 'T': 1.881} } data = { 'Planet': [], 'r (10^6 km)': [], 'T (years)': [], 'r\u00b3 (10^18 km\u00b3)': [], 'T\u00b2 (years\u00b2)': [] } for name, values in planets.items(): r = values['r'] T = values['T'] data['Planet'].append(name) data['r (10^6 km)'].append(r) data['T (years)'].append(T) data['r\u00b3 (10^18 km\u00b3)'].append((r**3) / 1e18) data['T\u00b2 (years\u00b2)'].append(T**2) df = pd.DataFrame(data) print(df) plt.plot(df['r\u00b3 (10^18 km\u00b3)'], df['T\u00b2 (years\u00b2)'], 'ro-', markersize=8) for i, txt in enumerate(df['Planet']): plt.annotate(txt, (df['r\u00b3 (10^18 km\u00b3)'][i], df['T\u00b2 (years\u00b2)'][i]), textcoords=\"offset points\", xytext=(5,5), ha='center') plt.xlabel(r'$r^3$ (in $10^{18}\\ km^3$)') plt.ylabel(r'$T^2$ (in $years^2$)') plt.title('Verification of Kepler\\'s Third Law with Solar System Planets') plt.grid(True) plt.show()","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#_3","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Orbital parameters (in astronomical units and years) radius = 1 # Orbital radius in AU period = 1 # Orbital period in years omega = 2 * np.pi / period # Angular velocity (rad/year) # Time array (convert years to days) t = np.linspace(0, period, 360) x = radius * np.cos(omega * t * 365) # X-position over time y = radius * np.sin(omega * t * 365) # Y-position over time # Set up the figure and axis fig, ax = plt.subplots(figsize=(6, 6)) ax.set_aspect('equal') ax.set_xlim(-1.5, 1.5) ax.set_ylim(-1.5, 1.5) ax.set_title(\"Circular Planet Orbit (Kepler's 3rd Law)\") ax.set_xlabel(\"X (AU)\") ax.set_ylabel(\"Y (AU)\") # Draw the Sun and initialize the planet sun = plt.Circle((0, 0), 0.05, color='gold', label='Sun') planet, = plt.plot([], [], 'o', color='blue', label='Planet') orbit, = plt.plot(x, y, linestyle='dotted', color='gray', alpha=0.5) # Add the Sun to the plot ax.add_artist(sun) ax.legend(loc=\"upper right\") # Animation update function def update(frame): # Modified to provide sequences to set_data planet.set_data([x[frame]], [y[frame]]) return planet, # Create animation ani = FuncAnimation(fig, update, frames=len(t), interval=30, blit=True) plt.show()","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"\ud83c\udf0c Gravity \u2013 Problem 2: The Three Cosmic Velocities \ud83c\udfaf Objective To derive and understand the three critical velocities in orbital mechanics \u2014 First Cosmic Velocity (orbital velocity) , Second Cosmic Velocity (escape velocity) , and Third Cosmic Velocity (solar system escape) \u2014 with calculations and comparisons for Earth, Moon, Mars, and Jupiter. \ud83d\udcd8 Key Concepts \ud83c\udf0d First Cosmic Velocity ( \\(v_1\\) ) \u2014 Orbital Velocity Definition : Minimum velocity required to maintain a circular orbit just above the surface of a celestial body. Derivation : The gravitational force provides the required centripetal force: $$ \\frac{G M m}{R^2} = \\frac{m v_1^2}{R} $$ Simplifying: $$ v_1 = \\sqrt{\\frac{G M}{R}} $$ \ud83d\ude80 Second Cosmic Velocity ( \\(v_2\\) ) \u2014 Escape Velocity Definition : Minimum velocity needed to escape the gravitational field of a body without further propulsion. Derivation : Set total mechanical energy to zero: $$ \\frac{1}{2}mv_2^2 - \\frac{G M m}{R} = 0 $$ Solving: $$ v_2 = \\sqrt{\\frac{2 G M}{R}} = \\sqrt{2} \\cdot v_1 $$ \ud83c\udf1e Third Cosmic Velocity ( \\(v_3\\) ) \u2014 Solar System Escape Definition : Minimum velocity needed to escape the gravitational field of the Sun, starting from Earth's orbit. Derivation (relative to Sun, neglecting Earth's gravity): $$ v_3 = \\sqrt{\\frac{2 G M_{sun}}{r_{earth_orbit}}} $$ \ud83c\udf0d Earth: Numerical Values Using: - \\(G = 6.674 \\times 10^{-11} \\ \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}\\) - \\(M_{earth} = 5.97 \\times 10^{24} \\ \\text{kg}\\) - \\(R_{earth} = 6.371 \\times 10^6 \\ \\text{m}\\) First cosmic velocity : $$ v_1 = \\sqrt{\\frac{G M}{R}} \\approx 7.91 \\ \\text{km/s} $$ Second cosmic velocity : $$ v_2 = \\sqrt{2} \\cdot v_1 \\approx 11.2 \\ \\text{km/s} $$ Third cosmic velocity (escape from Sun at Earth\u2019s orbit): $$ v_3 = \\sqrt{\\frac{2 G M_{sun}}{r_{earth_orbit}}} \\approx 42.1 \\ \\text{km/s} $$ \ud83c\udf10 Comparison Table Body Radius (m) Mass (kg) \\(v_1\\) (km/s) \\(v_2\\) (km/s) Earth \\(6.371 \\times 10^6\\) \\(5.97 \\times 10^{24}\\) 7.91 11.2 Moon \\(1.74 \\times 10^6\\) \\(7.35 \\times 10^{22}\\) 1.68 2.38 Mars \\(3.39 \\times 10^6\\) \\(6.42 \\times 10^{23}\\) 3.55 5.03 Jupiter \\(7.15 \\times 10^7\\) \\(1.90 \\times 10^{27}\\) 42.1 59.5 \ud83d\udcca Visualization Ideas Bar Chart : Compare \\(v_1\\) and \\(v_2\\) for Earth, Moon, Mars, and Jupiter. Orbit Diagram : Visualize scale and escape paths. Energy Diagram : Show kinetic vs potential energy during escape. \ud83d\udcce Notes Third cosmic velocity ( \\(v_3\\) ) assumes an object escapes directly from Earth\u2019s orbit from the Sun \u2014 not from the Earth's surface. Actual mission trajectories involve complex gravity assists and slingshots. \ud83d\udcda Further Reading NASA Solar System Dynamics Fundamentals of Astrodynamics \u2013 Bate, Mueller, White import matplotlib.pyplot as plt # Data bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] v1 = [7.9, 1.68, 3.55, 42.1] v2 = [11.2, 2.38, 5.03, 59.5] v3 = [16.7, None, 14.1, 18.5] # Moon doesn't have v3 in same sense x = range(len(bodies)) # Plot plt.figure(figsize=(10, 6)) plt.bar(x, v1, width=0.25, label='First Cosmic Velocity (v1)', align='center') plt.bar([i + 0.25 for i in x], v2, width=0.25, label='Second Cosmic Velocity (v2)', align='center') plt.bar([i + 0.5 for i in x], [v if v else 0 for v in v3], width=0.25, label='Third Cosmic Velocity (v3)', align='center') plt.xticks([i + 0.25 for i in x], bodies) plt.ylabel('Velocity (km/s)') plt.title('Comparison of Cosmic Velocities') plt.legend() plt.grid(True, linestyle='--', alpha=0.7) plt.show() import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3 kg^-1 s^-2 M = 5.972e24 # mass of Earth in kg (we'll keep it constant for this graph) # Generate a range of planet radii (in meters) radii = np.linspace(1e6, 1.5e7, 500) # from 1000 km to 15000 km # Calculate first cosmic velocity for each radius v1 = np.sqrt(G * M / radii) # Convert velocity to km/s v1_km_s = v1 / 1000 # Plotting plt.figure(figsize=(10,6)) plt.plot(radii/1000, v1_km_s, label='First Cosmic Velocity', color='blue') # radii in km plt.xlabel('Planet Radius (km)') plt.ylabel('First Cosmic Velocity (km/s)') plt.title('First Cosmic Velocity vs Planet Radius') plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.show() import numpy as np import matplotlib.pyplot as plt # Gravitational constant (m^3 kg^-1 s^-2) G = 6.67430e-11 # Planetary data: Radius (m), Mass (kg) bodies = { \"Earth\": {\"R\": 6.371e6, \"M\": 5.97e24}, \"Moon\": {\"R\": 1.74e6, \"M\": 7.35e22}, \"Mars\": {\"R\": 3.39e6, \"M\": 6.42e23}, \"Jupiter\": {\"R\": 7.15e7, \"M\": 1.90e27} } # Calculate second cosmic velocity (v2) for each body radii = [] v2_values = [] labels = [] for body, data in bodies.items(): R = data[\"R\"] M = data[\"M\"] v2 = np.sqrt(2 * G * M / R) / 1000 # Convert to km/s radii.append(R / 1e6) # Convert radius to millions of kilometers v2_values.append(v2) labels.append(body) # Plotting: Second Cosmic Velocity vs Planet Radius (only second velocity) plt.figure(figsize=(10, 6)) # Create bar plot for escape velocity (v2) plt.bar(labels, v2_values, color='orange') # Adding title and labels plt.title(\"Second Cosmic Velocity (Escape Velocity) vs Planet Radius\") plt.xlabel(\"Celestial Body\") plt.ylabel(\"Escape Velocity (km/s)\") # Annotating bars with values for escape velocity for i, value in enumerate(v2_values): plt.text(i, value + 0.5, f\"{value:.1f} km/s\", ha='center', va='bottom') plt.grid(axis='y', linestyle='--', alpha=0.6) plt.tight_layout() plt.show() import matplotlib.pyplot as plt # Data for celestial bodies and their third cosmic velocities (km/s) bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] v3 = [16.7, None, 14.1, 18.5] # Third Cosmic Velocity (v3), None for Moon as it doesn't apply x = range(len(bodies)) # Plotting the bar chart for third cosmic velocity plt.figure(figsize=(10, 6)) # Third Cosmic Velocity (v3), None for Moon, replace None with 0 for the plot plt.bar(x, [v if v else 0 for v in v3], width=0.5, label='Third Cosmic Velocity (v3)', color='purple', align='center') # Set x-ticks to be the body names plt.xticks(x, bodies) # Adding labels and title plt.ylabel('Velocity (km/s)') plt.title('Third Cosmic Velocity for Planet Radius') # Adding a legend plt.legend() # Grid for better visualization plt.grid(True, linestyle='--', alpha=0.7) # Show the plot plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt # Define a range of first cosmic velocities (v1) in km/s v1 = np.linspace(0, 20, 500) # Calculate second cosmic velocities (v2) v2 = np.sqrt(2) * v1 # Plotting plt.figure(figsize=(10,6)) plt.plot(v1, v2, label=r'$v_2 = \\sqrt{2} \\times v_1$', color='green') plt.plot(v1, v1, linestyle='--', color='gray', label=r'$v_2 = v_1$ (reference line)') plt.xlabel('First Cosmic Velocity $v_1$ (km/s)') plt.ylabel('Second Cosmic Velocity $v_2$ (km/s)') plt.title('Relationship between First and Second Cosmic Velocities') plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.show()","title":"\ud83c\udf0c Gravity \u2013 Problem 2: The Three Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravity-problem-2-the-three-cosmic-velocities","text":"","title":"\ud83c\udf0c Gravity \u2013 Problem 2: The Three Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#objective","text":"To derive and understand the three critical velocities in orbital mechanics \u2014 First Cosmic Velocity (orbital velocity) , Second Cosmic Velocity (escape velocity) , and Third Cosmic Velocity (solar system escape) \u2014 with calculations and comparisons for Earth, Moon, Mars, and Jupiter.","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/2%20Gravity/Problem_2/#key-concepts","text":"","title":"\ud83d\udcd8 Key Concepts"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1-orbital-velocity","text":"Definition : Minimum velocity required to maintain a circular orbit just above the surface of a celestial body. Derivation : The gravitational force provides the required centripetal force: $$ \\frac{G M m}{R^2} = \\frac{m v_1^2}{R} $$ Simplifying: $$ v_1 = \\sqrt{\\frac{G M}{R}} $$","title":"\ud83c\udf0d First Cosmic Velocity (\\(v_1\\)) \u2014 Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2-escape-velocity","text":"Definition : Minimum velocity needed to escape the gravitational field of a body without further propulsion. Derivation : Set total mechanical energy to zero: $$ \\frac{1}{2}mv_2^2 - \\frac{G M m}{R} = 0 $$ Solving: $$ v_2 = \\sqrt{\\frac{2 G M}{R}} = \\sqrt{2} \\cdot v_1 $$","title":"\ud83d\ude80 Second Cosmic Velocity (\\(v_2\\)) \u2014 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3-solar-system-escape","text":"Definition : Minimum velocity needed to escape the gravitational field of the Sun, starting from Earth's orbit. Derivation (relative to Sun, neglecting Earth's gravity): $$ v_3 = \\sqrt{\\frac{2 G M_{sun}}{r_{earth_orbit}}} $$","title":"\ud83c\udf1e Third Cosmic Velocity (\\(v_3\\)) \u2014 Solar System Escape"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earth-numerical-values","text":"Using: - \\(G = 6.674 \\times 10^{-11} \\ \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}\\) - \\(M_{earth} = 5.97 \\times 10^{24} \\ \\text{kg}\\) - \\(R_{earth} = 6.371 \\times 10^6 \\ \\text{m}\\) First cosmic velocity : $$ v_1 = \\sqrt{\\frac{G M}{R}} \\approx 7.91 \\ \\text{km/s} $$ Second cosmic velocity : $$ v_2 = \\sqrt{2} \\cdot v_1 \\approx 11.2 \\ \\text{km/s} $$ Third cosmic velocity (escape from Sun at Earth\u2019s orbit): $$ v_3 = \\sqrt{\\frac{2 G M_{sun}}{r_{earth_orbit}}} \\approx 42.1 \\ \\text{km/s} $$","title":"\ud83c\udf0d Earth: Numerical Values"},{"location":"1%20Physics/2%20Gravity/Problem_2/#comparison-table","text":"Body Radius (m) Mass (kg) \\(v_1\\) (km/s) \\(v_2\\) (km/s) Earth \\(6.371 \\times 10^6\\) \\(5.97 \\times 10^{24}\\) 7.91 11.2 Moon \\(1.74 \\times 10^6\\) \\(7.35 \\times 10^{22}\\) 1.68 2.38 Mars \\(3.39 \\times 10^6\\) \\(6.42 \\times 10^{23}\\) 3.55 5.03 Jupiter \\(7.15 \\times 10^7\\) \\(1.90 \\times 10^{27}\\) 42.1 59.5","title":"\ud83c\udf10 Comparison Table"},{"location":"1%20Physics/2%20Gravity/Problem_2/#visualization-ideas","text":"Bar Chart : Compare \\(v_1\\) and \\(v_2\\) for Earth, Moon, Mars, and Jupiter. Orbit Diagram : Visualize scale and escape paths. Energy Diagram : Show kinetic vs potential energy during escape.","title":"\ud83d\udcca Visualization Ideas"},{"location":"1%20Physics/2%20Gravity/Problem_2/#notes","text":"Third cosmic velocity ( \\(v_3\\) ) assumes an object escapes directly from Earth\u2019s orbit from the Sun \u2014 not from the Earth's surface. Actual mission trajectories involve complex gravity assists and slingshots.","title":"\ud83d\udcce Notes"},{"location":"1%20Physics/2%20Gravity/Problem_2/#further-reading","text":"NASA Solar System Dynamics Fundamentals of Astrodynamics \u2013 Bate, Mueller, White","title":"\ud83d\udcda Further Reading"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"import matplotlib.pyplot as plt # Data bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] v1 = [7.9, 1.68, 3.55, 42.1] v2 = [11.2, 2.38, 5.03, 59.5] v3 = [16.7, None, 14.1, 18.5] # Moon doesn't have v3 in same sense x = range(len(bodies)) # Plot plt.figure(figsize=(10, 6)) plt.bar(x, v1, width=0.25, label='First Cosmic Velocity (v1)', align='center') plt.bar([i + 0.25 for i in x], v2, width=0.25, label='Second Cosmic Velocity (v2)', align='center') plt.bar([i + 0.5 for i in x], [v if v else 0 for v in v3], width=0.25, label='Third Cosmic Velocity (v3)', align='center') plt.xticks([i + 0.25 for i in x], bodies) plt.ylabel('Velocity (km/s)') plt.title('Comparison of Cosmic Velocities') plt.legend() plt.grid(True, linestyle='--', alpha=0.7) plt.show()","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#_2","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3 kg^-1 s^-2 M = 5.972e24 # mass of Earth in kg (we'll keep it constant for this graph) # Generate a range of planet radii (in meters) radii = np.linspace(1e6, 1.5e7, 500) # from 1000 km to 15000 km # Calculate first cosmic velocity for each radius v1 = np.sqrt(G * M / radii) # Convert velocity to km/s v1_km_s = v1 / 1000 # Plotting plt.figure(figsize=(10,6)) plt.plot(radii/1000, v1_km_s, label='First Cosmic Velocity', color='blue') # radii in km plt.xlabel('Planet Radius (km)') plt.ylabel('First Cosmic Velocity (km/s)') plt.title('First Cosmic Velocity vs Planet Radius') plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.show()","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#_3","text":"import numpy as np import matplotlib.pyplot as plt # Gravitational constant (m^3 kg^-1 s^-2) G = 6.67430e-11 # Planetary data: Radius (m), Mass (kg) bodies = { \"Earth\": {\"R\": 6.371e6, \"M\": 5.97e24}, \"Moon\": {\"R\": 1.74e6, \"M\": 7.35e22}, \"Mars\": {\"R\": 3.39e6, \"M\": 6.42e23}, \"Jupiter\": {\"R\": 7.15e7, \"M\": 1.90e27} } # Calculate second cosmic velocity (v2) for each body radii = [] v2_values = [] labels = [] for body, data in bodies.items(): R = data[\"R\"] M = data[\"M\"] v2 = np.sqrt(2 * G * M / R) / 1000 # Convert to km/s radii.append(R / 1e6) # Convert radius to millions of kilometers v2_values.append(v2) labels.append(body) # Plotting: Second Cosmic Velocity vs Planet Radius (only second velocity) plt.figure(figsize=(10, 6)) # Create bar plot for escape velocity (v2) plt.bar(labels, v2_values, color='orange') # Adding title and labels plt.title(\"Second Cosmic Velocity (Escape Velocity) vs Planet Radius\") plt.xlabel(\"Celestial Body\") plt.ylabel(\"Escape Velocity (km/s)\") # Annotating bars with values for escape velocity for i, value in enumerate(v2_values): plt.text(i, value + 0.5, f\"{value:.1f} km/s\", ha='center', va='bottom') plt.grid(axis='y', linestyle='--', alpha=0.6) plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#_4","text":"import matplotlib.pyplot as plt # Data for celestial bodies and their third cosmic velocities (km/s) bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] v3 = [16.7, None, 14.1, 18.5] # Third Cosmic Velocity (v3), None for Moon as it doesn't apply x = range(len(bodies)) # Plotting the bar chart for third cosmic velocity plt.figure(figsize=(10, 6)) # Third Cosmic Velocity (v3), None for Moon, replace None with 0 for the plot plt.bar(x, [v if v else 0 for v in v3], width=0.5, label='Third Cosmic Velocity (v3)', color='purple', align='center') # Set x-ticks to be the body names plt.xticks(x, bodies) # Adding labels and title plt.ylabel('Velocity (km/s)') plt.title('Third Cosmic Velocity for Planet Radius') # Adding a legend plt.legend() # Grid for better visualization plt.grid(True, linestyle='--', alpha=0.7) # Show the plot plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#_5","text":"import numpy as np import matplotlib.pyplot as plt # Define a range of first cosmic velocities (v1) in km/s v1 = np.linspace(0, 20, 500) # Calculate second cosmic velocities (v2) v2 = np.sqrt(2) * v1 # Plotting plt.figure(figsize=(10,6)) plt.plot(v1, v2, label=r'$v_2 = \\sqrt{2} \\times v_1$', color='green') plt.plot(v1, v1, linestyle='--', color='gray', label=r'$v_2 = v_1$ (reference line)') plt.xlabel('First Cosmic Velocity $v_1$ (km/s)') plt.ylabel('Second Cosmic Velocity $v_2$ (km/s)') plt.title('Relationship between First and Second Cosmic Velocities') plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.show()","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}