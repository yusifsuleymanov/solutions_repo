<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Problem 2 - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Problem 2";
        var mkdocs_page_input_path = "1 Physics/6 Statistics/Problem_2.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Investigating the Dynamics of a Forced Damped Pendulum</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Gravity</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Gravity Problem 2: Derivation of Three Cosmic Velocities</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Problem 3: Trajectories of a Freely Released Payload Near Earth</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">🌊 Interference Patterns of Circular Water Waves from Point Sources</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Electromagnetism</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Circuits</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../5%20Circuits/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">6 Statistics</a>
<ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2 current"><a class="reference internal current" href="#">Problem 2</a>
<ul class="current">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">📊 Measurements</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">2 Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/1%20Linear_algebra/">Linear Algebra</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/2%20Analytic_geometry/">Analytic geometry</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/3%20Calculus/">Calculus</a>
</li>
</ul>
<p class="caption"><span class="caption-text">3 Discret Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal">1 Set Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/">Set Theory</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/">Relations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/">Functions</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Number Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/">Combinatorics</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/">Number Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Recurrence and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/">Sequences and Series</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/">Induction</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/">Recurrence</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Graph Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/">Graph Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Logic</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/5%20Logic/_01%20Logic/">Logic</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">6 Statistics</li>
<li class="breadcrumb-item active">Problem 2</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="problem-2">Problem 2</h1>
<h1 id="part-1-estimating-using-a-circle">📘 Part 1: Estimating π Using a Circle</h1>
<h2 id="1-theoretical-foundation">1. Theoretical Foundation</h2>
<h3 id="conceptual-overview">🧠 Conceptual Overview</h3>
<p>Monte Carlo methods use randomness to solve problems that might be deterministic in principle. For estimating π, we use the geometric relationship between a circle and its bounding square:</p>
<ul>
<li>Consider a <strong>unit circle</strong> (radius = 1) centered at the origin (0,0).</li>
<li>The circle is inscribed inside a <strong>square</strong> with side length 2, spanning coordinates from (-1, -1) to (1, 1).</li>
<li>The <strong>area</strong> of the unit circle is:</li>
</ul>
<p>$$
  A_{circle}=\pi r^2=\pi\cdot1^2=\pi
  $$</p>
<ul>
<li>The <strong>area</strong> of the square is:</li>
</ul>
<p>$$
  A_{square}=(2r)^2=(2\cdot1)^2=4
  $$</p>
<ul>
<li>The ratio of the areas is:</li>
</ul>
<p>$$
  \frac{A_{circle}}{A_{square}}=\frac{\pi}{4}
  $$</p>
<p>Thus, if we randomly generate points uniformly in the square, the <strong>probability</strong> that a point falls inside the circle is:</p>
<p>$$
  P(\text{point in circle})=\frac{\pi}{4}
  $$</p>
<h3 id="monte-carlo-estimation-of">🔢 Monte Carlo Estimation of π</h3>
<p>To estimate π using this geometric probability:</p>
<ol>
<li><strong>Generate</strong> a large number of random points <span class="arithmatex">\((x, y)\)</span> in the square <span class="arithmatex">\([-1, 1] \times [-1, 1]\)</span>.</li>
<li><strong>Check</strong> whether each point lies inside the unit circle using:</li>
</ol>
<p>$$
   x^2 + y^2 \leq 1
   $$</p>
<ol>
<li><strong>Count</strong> the number of points that fall inside the circle: <span class="arithmatex">\(N_{circle}\)</span></li>
<li><strong>Total</strong> number of generated points: <span class="arithmatex">\(N_{total}\)</span></li>
<li>Estimate π using:</li>
</ol>
<p>$$
   \hat{\pi}=4\cdot\frac{N_{circle}}{N_{total}}
   $$</p>
<h3 id="summary">✅ Summary</h3>
<ul>
<li>Monte Carlo estimation of π relies on simulating randomness and measuring proportions.</li>
<li>The larger the number of points <span class="arithmatex">\(N_{total}\)</span>, the more accurate the estimation.</li>
<li>This method visually and intuitively links <strong>geometry, probability, and numerical approximation</strong>.</li>
</ul>
<hr/>
<h2 id="_1"><img alt="alt text" src="../image-4.png"/></h2>
<pre><code class="language-python"># 🧪 Monte Carlo Estimation of Pi using Circle Method
import numpy as np
import matplotlib.pyplot as plt

# Number of random points to generate
N = 10000  # You can increase this for better accuracy

# Generate random (x, y) points in [-1, 1] x [-1, 1]
x = np.random.uniform(-1, 1, N)
y = np.random.uniform(-1, 1, N)

# Check if points fall inside the unit circle (x^2 + y^2 &lt;= 1)
inside_circle = x**2 + y**2 &lt;= 1

# Count how many are inside the circle
points_inside = np.sum(inside_circle)

# Estimate pi using the Monte Carlo formula
pi_estimate = 4 * points_inside / N

# Print result
print(f"Estimated π: {pi_estimate}")
print(f"Actual π: {np.pi}")
print(f"Error: {abs(np.pi - pi_estimate)}")

# 🎨 Visualization
fig, ax = plt.subplots(figsize=(6, 6))
ax.set_aspect('equal')
ax.set_title('Monte Carlo Estimation of π')

# Plot points
ax.scatter(x[inside_circle], y[inside_circle], color='blue', s=1, label='Inside Circle')
ax.scatter(x[~inside_circle], y[~inside_circle], color='red', s=1, label='Outside Circle')

# Draw the unit circle boundary for reference
circle = plt.Circle((0, 0), 1, color='black', fill=False, linewidth=2, label='Unit Circle')
ax.add_patch(circle)

# Set limits and labels
ax.set_xlim(-1, 1)
ax.set_ylim(-1, 1)
ax.legend(loc='upper right')
plt.grid(True)
plt.show()
</code></pre>
<h3 id="2-simulation">🖥 2. Simulation</h3>
<p>In this section, we implement a Monte Carlo simulation to estimate the value of π by randomly generating points in a square and analyzing how many fall within an inscribed circle.</p>
<h3 id="simulation-steps">🧪 Simulation Steps</h3>
<ul>
<li>We consider a <strong>unit circle</strong> of radius 1 centered at the origin <span class="arithmatex">\((0,0)\)</span>.</li>
<li>This circle is inscribed in a <strong>square</strong> with side length 2, which spans coordinates:</li>
</ul>
<p>$$
  [-1,1] \times [-1,1]
  $$</p>
<ul>
<li>The idea is to generate <span class="arithmatex">\(N\)</span> random points <span class="arithmatex">\((x, y)\)</span> uniformly within this square and count how many fall inside the circle.</li>
</ul>
<h3 id="inside-circle-criterion">➕ Inside Circle Criterion</h3>
<ul>
<li>A point <span class="arithmatex">\((x, y)\)</span> lies <strong>inside the unit circle</strong> if:</li>
</ul>
<p>$$
  x^2 + y^2 \leq 1
  $$</p>
<ul>
<li>Let <span class="arithmatex">\(N_{\text{circle}}\)</span> be the number of points that satisfy this condition.</li>
<li>Let <span class="arithmatex">\(N_{\text{total}}\)</span> be the total number of points generated.</li>
</ul>
<h3 id="monte-carlo-estimation-formula">🔢 Monte Carlo Estimation Formula</h3>
<ul>
<li>The probability of a point falling inside the circle is approximately:</li>
</ul>
<p>$$
  P = \frac{\pi}{4}
  $$</p>
<ul>
<li>Therefore, we estimate π using:</li>
</ul>
<p>$$
  \hat{\pi} = 4 \cdot \frac{N_{\text{circle}}}{N_{\text{total}}}
  $$</p>
<h3 id="notes">📝 Notes</h3>
<ul>
<li>The accuracy of the estimate improves as <span class="arithmatex">\(N_{\text{total}}\)</span> increases.</li>
<li>Randomness introduces variance; repeated runs may yield slightly different values.</li>
<li>This approach is simple but powerful and visually intuitive.</li>
</ul>
<h2 id="this-method-demonstrates-how-probabilistic-simulations-can-approximate-deterministic-mathematical-constants-using-geometry">&gt; ✅ This method demonstrates how probabilistic simulations can approximate deterministic mathematical constants using geometry.</h2>
<h3 id="3-visualization">3 Visualization</h3>
<p>The following Python code generates a scatter plot distinguishing points inside and outside the unit circle.
import numpy as np
import matplotlib.pyplot as plt</p>
<hr/>
<p><img alt="alt text" src="../indir2.gif"/></p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# Set random seed for reproducibility
np.random.seed(42)

def estimate_pi_circle(N):
    # Generate N random points in [-1, 1] x [-1, 1]
    x = np.random.uniform(-1, 1, N)
    y = np.random.uniform(-1, 1, N)

    # Check which points lie inside the unit circle
    inside_circle = x**2 + y**2 &lt;= 1
    M = np.sum(inside_circle)

    # Estimate pi
    pi_estimate = 4 * M / N

    return x, y, inside_circle, pi_estimate

# Run simulation with N = 10000
N = 10000
x, y, inside_circle, pi_estimate = estimate_pi_circle(N)

# Plot
plt.figure(figsize=(8, 8))
plt.scatter(x[inside_circle], y[inside_circle], c='blue', s=1, label='Inside Circle')
plt.scatter(x[~inside_circle], y[~inside_circle], c='red', s=1, label='Outside Circle')
circle = plt.Circle((0, 0), 1, edgecolor='black', facecolor='none')
plt.gca().add_patch(circle)
plt.gca().set_aspect('equal')
plt.xlim(-1, 1)
plt.ylim(-1, 1)
plt.title(f'Circle Method: π ≈ {pi_estimate:.5f}, N = {N}')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.grid(True)
plt.show()

print(f"Estimated π: {pi_estimate}")
</code></pre>
<h3 id="4-analysis">4 Analysis</h3>
<h2 id="_2"><img alt="alt text" src="../image-5.png"/></h2>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# Monte Carlo yöntemiyle pi tahmini fonksiyonu
def estimate_pi_circle(N):
    np.random.seed(0)  # Tekrarlanabilirlik için
    x = np.random.rand(N)
    y = np.random.rand(N)
    inside_circle = (x**2 + y**2) &lt;= 1
    count_inside = np.sum(inside_circle)
    pi_estimate = 4 * count_inside / N
    return x, y, inside_circle, pi_estimate

# Farklı nokta sayılarıyla hata analizi
Ns = np.logspace(2, 6, num=50, dtype=int)  # 100'den 1,000,000'a kadar logaritmik artışla
errors = []
pi_true = np.pi

for N in Ns:
    _, _, _, pi_estimate = estimate_pi_circle(N)
    errors.append(abs(pi_estimate - pi_true))

# Hata grafiği (log-log eksenlerde)
plt.figure(figsize=(10, 6))
plt.loglog(Ns, errors, 'o-', label='Absolute Error')
plt.title('Convergence of Circle-Based π Estimation')
plt.xlabel('Number of Points (N)')
plt.ylabel('Absolute Error |π_estimate - π|')
plt.grid(True, which='both')
plt.legend()
plt.tight_layout()
plt.show()
</code></pre>
<h1 id="part-2-estimating-using-buffons-needle">✅ PART 2: Estimating π Using Buffon’s Needle</h1>
<h2 id="1-theoretical-foundation_1">📘 1. Theoretical Foundation</h2>
<h3 id="introduction-to-buffons-needle-problem">🧠 Introduction to Buffon’s Needle Problem</h3>
<p>Buffon’s Needle is a classic probability problem that provides a method to estimate π using random trials involving dropping a needle on a plane ruled with parallel lines. The problem explores the probability that a needle of length <span class="arithmatex">\(L\)</span> dropped randomly onto a floor marked with parallel lines spaced <span class="arithmatex">\(d\)</span> units apart will cross one of these lines.</p>
<hr/>
<h3 id="problem-setup-and-assumptions">🔍 Problem Setup and Assumptions</h3>
<ul>
<li>The plane has <strong>parallel lines</strong> spaced at distance <span class="arithmatex">\(d\)</span> apart.</li>
<li>A needle of length <span class="arithmatex">\(L\)</span> is randomly thrown onto the plane.</li>
<li>The needle’s position is characterized by:</li>
<li>The distance <span class="arithmatex">\(x\)</span> from the needle’s center to the nearest line (with <span class="arithmatex">\(0 \leq x \leq \frac{d}{2}\)</span>).</li>
<li>The angle <span class="arithmatex">\(\theta\)</span> between the needle and the parallel lines, where <span class="arithmatex">\(\theta\)</span> is uniformly distributed in <span class="arithmatex">\([0, \frac{\pi}{2}]\)</span> due to symmetry.</li>
</ul>
<hr/>
<h3 id="condition-for-needle-crossing-a-line">📐 Condition for Needle Crossing a Line</h3>
<p>The needle crosses a line if the distance from the center to the closest line is less than or equal to half the projected length of the needle on the axis perpendicular to the lines:</p>
<div class="arithmatex">\[
x \leq \frac{L}{2} \sin \theta
\]</div>
<hr/>
<h3 id="probability-of-crossing">📊 Probability of Crossing</h3>
<p>The probability <span class="arithmatex">\(P\)</span> that a needle crosses a line is derived by integrating over all possible positions and orientations, yielding:</p>
<div class="arithmatex">\[
P = \frac{2L}{\pi d}
\]</div>
<p><em>This formula assumes <span class="arithmatex">\(L \leq d\)</span>.</em></p>
<hr/>
<h3 id="derivation-of-the-estimation-formula">🔢 Derivation of the π Estimation Formula</h3>
<p>Let:</p>
<ul>
<li><span class="arithmatex">\(L\)</span> = length of the needle  </li>
<li><span class="arithmatex">\(d\)</span> = distance between the parallel lines  </li>
<li><span class="arithmatex">\(N\)</span> = total number of needle throws  </li>
<li><span class="arithmatex">\(C\)</span> = number of times the needle crosses a line  </li>
</ul>
<p>From the observed experimental probability,</p>
<div class="arithmatex">\[
P \approx \frac{C}{N}
\]</div>
<p>and equating to the theoretical probability,</p>
<div class="arithmatex">\[
\frac{C}{N} \approx \frac{2L}{\pi d}
\]</div>
<p>Solving for π, we get the estimate:</p>
<div class="arithmatex">\[
\boxed{
\pi \approx \frac{2 L N}{d C}
}
\]</div>
<hr/>
<h3 id="summary_1">✅ Summary</h3>
<ul>
<li>Buffon’s Needle problem connects geometry and probability to estimate π.</li>
<li>It provides an elegant, physical experiment-based approach to numerical estimation.</li>
<li>Accuracy improves as <span class="arithmatex">\(N\)</span> (number of needle throws) increases.</li>
<li>The problem is a foundational example in geometric probability and Monte Carlo methods.</li>
</ul>
<h2 id="2-simulation_1">2. Simulation</h2>
<p>We now implement the simulation of Buffon’s Needle experiment to estimate π.</p>
<h3 id="simulation-procedure">Simulation Procedure</h3>
<ul>
<li><strong>Step 1:</strong> Simulate <span class="arithmatex">\(N\)</span> random needle drops on a plane with parallel lines spaced by distance <span class="arithmatex">\(d\)</span>.</li>
<li><strong>Step 2:</strong> For each needle drop:</li>
<li>Sample the needle's center position <span class="arithmatex">\(x\)</span> uniformly from <span class="arithmatex">\([0, d/2]\)</span>.</li>
<li>Sample the needle's orientation angle <span class="arithmatex">\(\theta\)</span> uniformly from <span class="arithmatex">\([0, \pi/2]\)</span>.</li>
<li><strong>Step 3:</strong> Determine whether the needle crosses a line by checking the condition:</li>
</ul>
<div class="arithmatex">\[
x \leq \frac{L}{2} \sin \theta
\]</div>
<ul>
<li><strong>Step 4:</strong> Count the number of crossings <span class="arithmatex">\(C\)</span>.</li>
<li><strong>Step 5:</strong> Estimate π using the formula:</li>
</ul>
<div class="arithmatex">\[
\hat{\pi} = \frac{2 L N}{d C}
\]</div>
<hr/>
<h2 id="_3"><img alt="alt text" src="../image-6.png"/></h2>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def simulate_buffon(L=1.0, d=1.5, num_drops=10000):
    """
    Estimate π using Buffon's Needle method.

    Parameters:
    - L: needle length
    - d: spacing between the parallel lines (should be ≥ L)
    - num_drops: total needle throws

    Returns:
    - pi_approx: estimated value of π
    - did_cross: boolean array indicating crossing needles
    - centers, thetas: arrays of needle center x-coordinates and angles
    """
    centers = np.random.uniform(0, d/2, num_drops)
    thetas = np.random.uniform(-np.pi/2, np.pi/2, num_drops)
    did_cross = centers &lt;= (L/2) * np.abs(np.sin(thetas))
    hits = np.count_nonzero(did_cross)
    pi_approx = (2 * L * num_drops) / (d * hits) if hits &gt; 0 else np.nan

    return pi_approx, did_cross, centers, thetas

def visualize_needles(centers, thetas, did_cross, L=1.0, d=1.5, x_limit=None):
    """
    Plot the result of Buffon's Needle simulation:
    - Show parallel lines
    - Plot needles in two colors based on crossing

    Parameters:
    - centers, thetas: x positions and angles of needles
    - did_cross: array indicating if needle crosses a line
    - L: length of each needle
    - d: distance between the lines
    - x_limit: max x-axis value for plotting
    """
    if x_limit is None:
        x_limit = np.max(centers) + d

    plt.figure(figsize=(10, 5))
    plt.title("Buffon's Needle Experiment")

    # Draw the parallel lines
    num_lines = int(np.ceil(x_limit / d)) + 1
    for i in range(num_lines):
        plt.axvline(i * d, color='gray', linestyle=':', linewidth=1.2)

    y_offset = 0
    for x, theta, cross in zip(centers, thetas, did_cross):
        dx = (L/2) * np.cos(theta)
        dy = (L/2) * np.sin(theta)
        x0, x1 = x - dx, x + dx
        y0, y1 = y_offset - dy, y_offset + dy
        clr = 'orange' if cross else 'green'
        plt.plot([x0, x1], [y0, y1], color=clr, lw=1.8)

    plt.xlim(0, x_limit)
    plt.ylim(-L, L)
    plt.xlabel("X Position")
    plt.ylabel("Y Position")
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.tight_layout()
    plt.show()

# Kullanım örneği:
L = 1.0
d = 1.5
N = 10000

pi_approx, did_cross, centers, thetas = simulate_buffon(L, d, N)
print(f"π yaklaşık değeri ({N} deneme): {pi_approx:.6f}")

# Görselleştirme (örnek 200 iğne)
visualize_needles(centers[:200], thetas[:200], did_cross[:200], L, d)
</code></pre>
<h2 id="_4"><img alt="alt text" src="../image-7.png"/></h2>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# Parameters
needle_length = 1.0       # Length of each needle
line_spacing = 1.5        # Distance between parallel lines
num_needles = 200         # Number of needles to visualize

# Generate random horizontal positions for the centers
center_x_positions = np.random.uniform(0, 6 * line_spacing, num_needles)

# Generate random angles in [-π/2, π/2] for more variety
needle_angles = np.random.uniform(-np.pi/2, np.pi/2, num_needles)

# Calculate wrapped x values and determine crossings
wrapped_positions = center_x_positions % line_spacing
is_crossing = np.abs(wrapped_positions) &lt;= (needle_length / 2) * np.abs(np.sin(needle_angles))

# Set up the plot
plt.figure(figsize=(11, 5))
plt.title("Modified Buffon's Needle Visualization")

# Draw dashed vertical lines
x_max = np.max(center_x_positions) + line_spacing
for x in np.arange(0, x_max, line_spacing):
    plt.axvline(x, color='gray', linestyle='--', linewidth=1)

# Plot each needle
for x_center, angle, crossed in zip(center_x_positions, needle_angles, is_crossing):
    dx = (needle_length / 2) * np.cos(angle)
    dy = (needle_length / 2) * np.sin(angle)

    x0, x1 = x_center - dx, x_center + dx
    y0, y1 = -dy, dy

    needle_color = 'orange' if crossed else 'green'
    plt.plot([x0, x1], [y0, y1], color=needle_color, linewidth=2)

# Axis labels and limits
plt.xlabel("X-axis (Needle Center Position)")
plt.ylabel("Y-axis (Needle Projection)")
plt.xlim(0, x_max)
plt.ylim(-needle_length, needle_length)
plt.grid(True, linestyle=':', alpha=0.7)
plt.tight_layout()
plt.show()
</code></pre>
<h2 id="4-analysis_1">4. Analysis</h2>
<p>We analyze the convergence behavior of the Buffon’s Needle simulation and compare it with the circle-based Monte Carlo method for estimating π.</p>
<hr/>
<h3 id="objectives">🔍 Objectives</h3>
<ul>
<li>Run the Buffon’s Needle simulation for increasing numbers of throws <span class="arithmatex">\(N\)</span>.</li>
<li>Observe how the estimate of π improves (converges) as <span class="arithmatex">\(N\)</span> increases.</li>
<li>Plot the convergence of π estimates against the number of throws.</li>
<li>Compare the convergence rate and accuracy with the circle-based Monte Carlo method.</li>
</ul>
<hr/>
<h3 id="methodology">📈 Methodology</h3>
<ul>
<li>Define a range of sample sizes: <span class="arithmatex">\(N_1 &lt; N_2 &lt; \dots &lt; N_k\)</span>.</li>
<li>For each <span class="arithmatex">\(N_i\)</span>:</li>
<li>Run the Buffon’s Needle simulation and record the estimated π value, <span class="arithmatex">\(\hat{\pi}_{needle}(N_i)\)</span>.</li>
<li>Run the circle-based Monte Carlo simulation and record the estimated π value, <span class="arithmatex">\(\hat{\pi}_{circle}(N_i)\)</span>.</li>
<li>Plot <span class="arithmatex">\(\hat{\pi}\)</span> vs. <span class="arithmatex">\(N\)</span> for both methods on the same graph.</li>
<li>Analyze the error:</li>
</ul>
<div class="arithmatex">\[
\text{Error}(N) = \left|\pi - \hat{\pi}(N)\right|
\]</div>
<hr/>
<h3 id="python-implementation-for-analysis">🔧 Python Implementation for Analysis</h3>
<p><img alt="alt text" src="../image-8.png"/>
<img alt="alt text" src="../image-9.png"/></p>
<hr/>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# Buffon's Needle simulation function
def buffon_needle_pi_estimate(L, d, N):
    x_centers = np.random.uniform(0, d/2, N)
    angles = np.random.uniform(0, np.pi/2, N)
    crossings = x_centers &lt;= (L/2)*np.sin(angles)
    C = np.sum(crossings)
    if C == 0:
        return np.nan
    return (2 * L * N) / (d * C)

# Circle-based Monte Carlo π estimation
def monte_carlo_circle_pi(N):
    points = np.random.uniform(-1, 1, (N, 2))
    inside_circle = np.sum(points[:,0]**2 + points[:,1]**2 &lt;= 1)
    return 4 * inside_circle / N

# Parameters
L = 1.0
d = 1.5
sample_sizes = np.logspace(2, 5, num=20, dtype=int)  # From 100 to 100,000 throws

needle_estimates = []
circle_estimates = []

for N in sample_sizes:
    pi_needle = buffon_needle_pi_estimate(L, d, N)
    pi_circle = monte_carlo_circle_pi(N)
    needle_estimates.append(pi_needle)
    circle_estimates.append(pi_circle)

# Plotting convergence
plt.figure(figsize=(10,6))
plt.plot(sample_sizes, needle_estimates, 'o-', label="Buffon's Needle")
plt.plot(sample_sizes, circle_estimates, 's-', label="Circle Monte Carlo")
plt.axhline(np.pi, color='k', linestyle='--', label="True π")
plt.xscale('log')
plt.xlabel("Number of Throws (log scale)")
plt.ylabel("Estimated π")
plt.title("Convergence of π Estimation Methods")
plt.legend()
plt.grid(True)
plt.show()

# Plot absolute errors
plt.figure(figsize=(10,6))
plt.plot(sample_sizes, np.abs(np.pi - np.array(needle_estimates)), 'o-', label="Buffon's Needle Error")
plt.plot(sample_sizes, np.abs(np.pi - np.array(circle_estimates)), 's-', label="Circle Monte Carlo Error")
plt.xscale('log')
plt.yscale('log')
plt.xlabel("Number of Throws (log scale)")
plt.ylabel("Absolute Error (log scale)")
plt.title("Error Convergence of π Estimation Methods")
plt.legend()
plt.grid(True, which="both")
plt.show()
</code></pre>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../Problem_1/" title="Problem 1"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../7%20Measurements/Problem_1/" title="📊 Measurements">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../7%20Measurements/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
